---
import ReceiptLayout from "../layouts/ReceiptLayout.astro";
import Avatar from '../assets/index/images/andrewwashuta.png';
---

<ReceiptLayout
  description="New Mexico-based product and visual designer crafting empathy-driven digital experiences. Receipt printer portfolio."
>
  <!-- Toolbar -->
  <div class="toolbar" id="toolbar">
    <button class="toolbar-btn active" id="soundToggle" aria-label="Toggle sounds" title="Toggle sounds">
      <span class="toolbar-label">Sound</span>
      <span class="toolbar-icon" id="soundIcon">&#x1F50A;</span>
      <span class="toolbar-key">S</span>
    </button>
    <button class="toolbar-btn" id="tapeToggle" aria-label="Toggle washi tape" title="Toggle washi tape">
      <span class="toolbar-label">Washi</span>
      <span class="toolbar-icon" id="tapeIcon">&#x1F48A;</span>
      <span class="toolbar-key">W</span>
    </button>
    <button class="toolbar-btn toolbar-btn--washi-only" id="clearTape" aria-label="Clear tape" title="Clear tape">
      <span class="toolbar-label">Clear</span>
      <span class="toolbar-icon">&#x1F5D1;</span>
      <span class="toolbar-key">C</span>
    </button>
  </div>

  <!-- Inverse cursor dot (desktop only) -->
  <div class="cursor-dot" id="cursorDot">
    <div class="cursor-half cursor-half-top"></div>
    <div class="cursor-half cursor-half-bottom"></div>
  </div>

  <div class="receipt-wrapper">
    <div class="receipt" id="receipt">

      <!-- ============================================ -->
      <!-- TOP EDGE (torn from previous receipt)        -->
      <!-- ============================================ -->
      <div class="receipt-top-tear" data-print></div>

      <!-- ============================================ -->
      <!-- STORE HEADER                                  -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line center divider" data-print>================================</pre>
        <pre class="receipt-line center big" data-print>    ANDREW WASHUTA</pre>
        <pre class="receipt-line center" data-print>    PRODUCT DESIGNER</pre>
        <pre class="receipt-line center divider" data-print>================================</pre>
      </div>

      <!-- ============================================ -->
      <!-- TRANSACTION META (dynamic via JS)             -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line" data-print>DATE: <span id="receiptDate">loading...</span></pre>
        <pre class="receipt-line" data-print>ORDER #: <span id="receiptOrder">-----</span></pre>
        <pre class="receipt-line" data-print>CASHIER: THE INTERNET</pre>
        <pre class="receipt-line" data-print>--------------------------------</pre>
      </div>

      <!-- ============================================ -->
      <!-- ABOUT                                         -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line bold" data-print>ABOUT</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line wrap" data-print>Hey there, I'm Andrew — husband, dad, trail runner, Parks lover, designer. Based in New Mexico.</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line wrap" data-print>Currently shipping ad platforms and leading design systems at 84.51° by day, while building a wrapped asset protocol at Universal by night.</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line wrap" data-print>I believe in empathy-driven design built through collaboration with teams that care deeply about the people using their products.</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line row" data-print><span>LOCATION:</span><span>Albuquerque, NM</span></pre>
        <pre class="receipt-line row" data-print><span>ELEVATION:</span><span>5,312 ft</span></pre>
        <pre class="receipt-line" data-print>--------------------------------</pre>
      </div>

      <!-- ============================================ -->
      <!-- SKILLS                                        -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line bold" data-print>SKILLS</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line row" data-print><span>  1x  Product Design</span><span>****</span></pre>
        <pre class="receipt-line row" data-print><span>  1x  Design Systems</span><span>****</span></pre>
        <pre class="receipt-line row" data-print><span>  1x  Visual Design</span><span>****</span></pre>
        <pre class="receipt-line row" data-print><span>  1x  Brand Design</span><span>****</span></pre>
        <pre class="receipt-line row" data-print><span>  1x  Prototyping</span><span>****</span></pre>
        <pre class="receipt-line row" data-print><span>  1x  Front-end Dev</span><span>****</span></pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line row bold" data-print><span>  SUBTOTAL (6 items)</span><span>PRICELESS</span></pre>
        <pre class="receipt-line" data-print>--------------------------------</pre>
      </div>

      <!-- ============================================ -->
      <!-- PORTRAIT (Dithered)                           -->
      <!-- ============================================ -->
      <div class="receipt-section portrait-section" data-print-section>
        <div class="portrait-container" data-print data-src={Avatar.src}>
          <canvas id="portraitCanvas"></canvas>
          <noscript>
            <img src={Avatar.src} alt="Andrew Washuta" width="280" />
          </noscript>
        </div>
        <pre class="receipt-line center faded" data-print>[ THERMAL PORTRAIT ]</pre>
        <pre class="receipt-line" data-print>--------------------------------</pre>
      </div>

      <!-- ============================================ -->
      <!-- EXPERIENCE                                    -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line bold" data-print>EXPERIENCE</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line bold" data-print>  84.51°, A Kroger Company</pre>
        <pre class="receipt-line faded" data-print>  Lead Product Designer</pre>
        <pre class="receipt-line dotleader" data-print><span>  Ad Platforms</span><span>2025-NOW</span></pre>
        <pre class="receipt-line dotleader" data-print><span>  Design Systems</span><span>2021-2025</span></pre>
        <pre class="receipt-line dotleader" data-print><span>  Insights</span><span>2017-2021</span></pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line bold" data-print>  Universal.xyz</pre>
        <pre class="receipt-line dotleader" data-print><span>  Design Lead</span><span>2022-NOW</span></pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line bold" data-print>  Clubessential</pre>
        <pre class="receipt-line dotleader" data-print><span>  Web Designer</span><span>2016-2017</span></pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line bold" data-print>  UnitedHealthcare</pre>
        <pre class="receipt-line dotleader" data-print><span>  Brand Designer</span><span>2014-2016</span></pre>
        <pre class="receipt-line" data-print>--------------------------------</pre>
      </div>

      <!-- ============================================ -->
      <!-- NOW                                           -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line bold" data-print>CURRENTLY</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line wrap" data-print>  * Cherishing every moment with my wife, Seneca, and our kiddos, Thor and Raya</pre>
        <pre class="receipt-line wrap" data-print>  * Living as a "cyborg" healing a broken hip socket</pre>
        <pre class="receipt-line wrap" data-print>  * Dreaming up recipes with unique ingredients</pre>
        <pre class="receipt-line wrap" data-print>  * Collecting vintage National Park brochures</pre>
        <pre class="receipt-line wrap" data-print>  * Falling back in love with code</pre>
        <pre class="receipt-line" data-print>--------------------------------</pre>
      </div>

      <!-- ============================================ -->
      <!-- EDUCATION                                     -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line bold" data-print>EDUCATION</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line bold" data-print>  Clarkson University</pre>
        <pre class="receipt-line" data-print>  B.S. Digital Arts & Sciences</pre>
        <pre class="receipt-line" data-print>  Minor: Business Administration</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line center divider" data-print>================================</pre>
      </div>

      <!-- ============================================ -->
      <!-- SUBTOTAL / CONTACT                            -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line bold" data-print>CONTACT</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line row" data-print><span>WEB</span><span><a href="https://andrew.cv">andrew.cv</a></span></pre>
        <pre class="receipt-line row" data-print><span>EMAIL</span><span><a href="mailto:hello@andrew.cv">hello@andrew.cv</a></span></pre>
        <pre class="receipt-line row" data-print><span>LINKEDIN</span><span><a href="https://linkedin.com/in/awashuta" target="_blank">/in/awashuta</a></span></pre>
        <pre class="receipt-line row" data-print><span>X</span><span><a href="https://x.com/awashuta" target="_blank">@awashuta</a></span></pre>
        <pre class="receipt-line row" data-print><span>INSTAGRAM</span><span><a href="https://instagram.com/andrewwashuta" target="_blank">@andrewwashuta</a></span></pre>
        <pre class="receipt-line row" data-print><span>REFRAKT</span><span><a href="https://refrakt.app/andrew" target="_blank">refrakt.app/andrew</a></span></pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line center divider" data-print>================================</pre>
      </div>

      <!-- ============================================ -->
      <!-- BARCODE                                       -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <div class="barcode-container" data-print>
          <canvas id="barcodeCanvas" width="200" height="50"></canvas>
        </div>
        <pre class="receipt-line center faded" data-print id="barcodeNumber">0000 0000 0000</pre>
      </div>

      <!-- ============================================ -->
      <!-- VISITOR COUNTER                               -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line row" data-print><span>GUESTS SERVED:</span><span id="visitorCount">00000</span></pre>
        <pre class="receipt-line" data-print>--------------------------------</pre>
      </div>

      <!-- ============================================ -->
      <!-- FOOTER / THANK YOU                            -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line center bold" data-print>THANK YOU FOR VISITING!</pre>
        <pre class="receipt-line center faded" data-print>Have a great day.</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line center faded small" data-print>Items sold final.</pre>
        <pre class="receipt-line center faded small" data-print>No returns on experience.</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line center faded" data-print>- - - - - - - - - - - - - - -</pre>
        <pre class="receipt-line center faded" data-print>&#x2702; TEAR ANYWHERE &#x2014; 2026 &#x2702;</pre>
      </div>

      <!-- Bottom torn edge -->
      <div class="receipt-bottom-tear" data-print></div>

    </div>
  </div>
</ReceiptLayout>

<style>
  /* ============================================ */
  /* RECEIPT WRAPPER & CONTAINER                   */
  /* ============================================ */

  .receipt-wrapper {
    display: flex;
    justify-content: center;
    position: relative;
    width: 100%;
    max-width: 100%;
  }

  .receipt {
    width: 380px;
    max-width: 100%;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    background: #ede7d9;
    background-image:
      linear-gradient(
        180deg,
        rgba(160,120,60,0.04) 0%,
        transparent 3%,
        transparent 50%,
        rgba(160,120,60,0.02) 80%,
        rgba(0,0,0,0.04) 100%
      );
    padding: 32px 24px;
    position: relative;
    transform: rotate(-1.2deg);
    box-shadow:
      0 1px 4px rgba(0,0,0,0.2),
      0 4px 16px rgba(0,0,0,0.15),
      0 12px 48px rgba(0,0,0,0.1);
    overflow: hidden;
    filter: sepia(0.08) saturate(0.95);
  }

  .receipt * {
    user-select: none;
    -webkit-user-select: none;
    -webkit-user-drag: none;
  }

  /* Paper texture overlay - subtle horizontal feed lines */
  .receipt::before {
    content: "";
    position: absolute;
    inset: 0;
    background-image:
      repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0,0,0,0.012) 2px,
        rgba(0,0,0,0.012) 3px
      );
    pointer-events: none;
    z-index: 2;
  }

  /* Noise texture for paper grain */
  .receipt::after {
    content: "";
    position: absolute;
    inset: 0;
    opacity: 0.45;
    pointer-events: none;
    z-index: 1;
    mix-blend-mode: multiply;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.2' numOctaves='5' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.12'/%3E%3C/svg%3E");
    background-size: 200px 200px;
  }

  /* Top torn edge - from previous receipt */
  .receipt-top-tear {
    position: absolute;
    top: -6px;
    left: 0;
    right: 0;
    height: 8px;
    background: #ede7d9;
    clip-path: polygon(
      0% 100%, 2% 40%, 4% 100%, 6% 50%, 8% 100%, 10% 30%, 
      12% 100%, 14% 60%, 16% 100%, 18% 40%, 20% 100%, 22% 50%,
      24% 100%, 26% 30%, 28% 100%, 30% 60%, 32% 100%, 34% 40%,
      36% 100%, 38% 50%, 40% 100%, 42% 30%, 44% 100%, 46% 60%,
      48% 100%, 50% 40%, 52% 100%, 54% 50%, 56% 100%, 58% 30%,
      60% 100%, 62% 60%, 64% 100%, 66% 40%, 68% 100%, 70% 50%,
      72% 100%, 74% 30%, 76% 100%, 78% 60%, 80% 100%, 82% 40%,
      84% 100%, 86% 50%, 88% 100%, 90% 30%, 92% 100%, 94% 60%,
      96% 100%, 98% 40%, 100% 100%
    );
    z-index: 3;
  }

  /* Bottom torn edge */
  .receipt-bottom-tear {
    position: absolute;
    bottom: -8px;
    left: 0;
    right: 0;
    height: 10px;
    background: #ede7d9;
    clip-path: polygon(
      0% 0%, 3% 70%, 5% 0%, 8% 60%, 11% 0%, 13% 80%, 
      16% 0%, 19% 50%, 21% 0%, 24% 70%, 27% 0%, 29% 60%,
      32% 0%, 35% 80%, 37% 0%, 40% 50%, 43% 0%, 45% 70%,
      48% 0%, 51% 60%, 53% 0%, 56% 80%, 59% 0%, 61% 50%,
      64% 0%, 67% 70%, 69% 0%, 72% 60%, 75% 0%, 77% 80%,
      80% 0%, 83% 50%, 85% 0%, 88% 70%, 91% 0%, 93% 60%,
      96% 0%, 98% 80%, 100% 0%
    );
    z-index: 3;
  }

  /* ============================================ */
  /* RECEIPT LINES                                 */
  /* ============================================ */

  .receipt-section {
    position: relative;
    z-index: 3;
  }

  .receipt-line {
    font-family: var(--font-receipt);
    font-size: 18px;
    line-height: 1.5;
    color: #1a1a1a;
    white-space: pre;
    margin: 0;
    padding: 0;
    border: none;
    background: none;
    display: block;
    opacity: 0;
    transform: translateY(1px);
    position: relative;
    overflow: hidden;
  }

  .receipt-line.printed {
    opacity: 1;
    transform: translateY(0);
  }

  .receipt-line.wrap {
    white-space: pre-wrap;
    word-wrap: break-word;
    max-width: 100%;
  }

  .receipt-line.center {
    text-align: center;
  }

  .receipt-line.big {
    font-family: var(--font-pixel);
    font-size: 14px;
    font-weight: 900;
    letter-spacing: 2px;
    text-shadow: 0.5px 0 0 currentColor;
  }

  .receipt-line.bold {
    font-family: var(--font-pixel);
    color: #000;
    font-weight: 800;
    letter-spacing: 1px;
    font-size: 14px;
    text-shadow: 0.3px 0 0 currentColor;
  }

  .receipt-line.divider {
    font-family: var(--font-pixel);
    font-size: 14px;
    font-weight: 700;
    color: #444;
  }

  .receipt-line.faded {
    color: #888;
  }

  .receipt-line.small {
    font-size: 14px;
  }

  .receipt-line.spacer {
    line-height: 0.8;
  }

  /* Row layout for aligned columns */
  .receipt-line.row {
    display: flex;
    justify-content: space-between;
    gap: 8px;
  }

  .receipt-line.row.printed {
    display: flex;
  }

  .receipt-line.row span {
    white-space: nowrap;
  }

  /* Dot-leader rows (experience items) */
  .receipt-line.dotleader {
    display: flex;
    gap: 0;
    overflow: hidden;
  }

  .receipt-line.dotleader.printed {
    display: flex;
  }

  .receipt-line.dotleader span:first-child {
    white-space: nowrap;
    flex-shrink: 0;
    order: 1;
  }

  .receipt-line.dotleader span:last-child {
    white-space: nowrap;
    flex-shrink: 0;
    order: 3;
  }

  /* Dotted line fills the gap between spans */
  .receipt-line.dotleader::before {
    content: "";
    order: 2;
    flex: 1;
    border-bottom: 1px dotted #bbb;
    margin: 0 4px;
    margin-bottom: 5px;
    min-width: 8px;
  }

  /* Subtle print artifact - random slight offset on some lines */
  .receipt-line.artifact {
    transform: translateX(0.5px);
  }

  /* Links in receipt */
  .receipt-line :global(a) {
    color: #1a1a1a;
    text-decoration: underline;
    text-decoration-style: dashed;
    text-underline-offset: 3px;
    text-decoration-thickness: 1px;
    text-decoration-color: #999;
    transition: color 0.15s, text-decoration-color 0.15s;
    pointer-events: auto;
    cursor: pointer;
  }

  .receipt-line :global(a:hover) {
    color: #555;
    text-decoration-color: #555;
  }

  /* Barcode */
  .barcode-container {
    display: flex;
    justify-content: center;
    margin: 8px 0 4px;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .barcode-container.printed {
    opacity: 1;
  }

  #barcodeCanvas {
    display: block;
    width: 200px;
    height: 50px;
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
  }

  /* ============================================ */
  /* PORTRAIT                                      */
  /* ============================================ */

  .portrait-container {
    width: 100%;
    display: flex;
    justify-content: center;
    margin: 8px 0;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .portrait-container.printed {
    opacity: 1;
  }

  #portraitCanvas,
  .portrait-img {
    width: 100%;
    max-width: 280px;
    height: auto;
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
  }

  /* ============================================ */
  /* PRINT CURSOR EFFECT                           */
  /* ============================================ */

  .receipt-line.printing {
    transition: opacity 0.05s ease, transform 0.05s ease;
  }

  .receipt-line.printing:not(.row):not(.dotleader):not(.spacer)::after {
    content: "█";
    animation: blink 0.4s step-end infinite;
    color: #1a1a1a;
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }

  /* ============================================ */
  /* TOOLBAR                                        */
  /* ============================================ */

  .toolbar {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 100;
    display: flex;
    flex-direction: column;
    background: rgba(30, 28, 24, 0.85);
    border: 1px solid rgba(245, 240, 232, 0.12);
    padding: 4px;
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
  }

  .toolbar-btn {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 36px;
    background: transparent;
    border: none;
    color: rgba(245, 240, 232, 0.5);
    cursor: pointer;
    transition: color 0.2s, background 0.2s;
    padding: 0;
    margin: 0;
  }

  .toolbar-btn + .toolbar-btn {
    margin-top: 2px;
  }

  .toolbar-btn.active {
    color: rgba(244, 236, 215, 0.86);
    background: rgba(48, 40, 26, 0.88);
  }

  .toolbar-btn:hover {
    color: rgba(245, 240, 232, 0.7);
  }

  .toolbar-icon {
    font-family: var(--font-thermo), sans-serif;
    font-weight: 400;
    font-size: 20px;
    line-height: 1;
  }

  .toolbar-key {
    position: absolute;
    bottom: 2px;
    right: 3px;
    font-family: var(--font-receipt);
    font-size: 12px;
    opacity: 0.45;
    line-height: 1;
  }

  .toolbar-label {
    position: absolute;
    right: calc(100% + 8px);
    top: 50%;
    transform: translateY(-50%) translateX(4px);
    white-space: nowrap;
    font-family: var(--font-receipt);
    font-size: 12px;
    letter-spacing: 1px;
    background: rgba(30, 28, 24, 0.9);
    padding: 3px 8px;
    border: 1px solid rgba(245, 240, 232, 0.12);
    color: rgba(245, 240, 232, 0.7);
    opacity: 0;
    pointer-events: none;
    filter: blur(3px);
    transition: opacity 0.2s ease, transform 0.2s ease, filter 0.2s ease;
  }

  .toolbar-btn:hover .toolbar-label {
    opacity: 1;
    transform: translateY(-50%) translateX(0);
    filter: blur(0);
  }

  .toolbar-btn--washi-only {
    max-height: 0;
    margin-top: 0;
    overflow: hidden;
    opacity: 0;
    transition: max-height 0.25s ease, opacity 0.2s ease, margin-top 0.25s ease;
  }

  :global(body.washi-mode) .toolbar-btn--washi-only {
    max-height: 36px;
    margin-top: 2px;
    opacity: 1;
  }

  .toolbar-btn--pressed {
    color: rgba(245, 240, 232, 0.7);
  }

  :global(.washi-preview),
  :global(.washi-strip) {
    border: none;
    border-radius: 3px;
    background-color: rgba(236, 236, 236, 0.72);
    background:
      linear-gradient(
        180deg,
        rgba(255, 255, 255, calc(var(--washi-alpha, 0.72) * 0.35)) 0%,
        rgba(230, 230, 230, calc(var(--washi-alpha, 0.72) * 0.25)) 100%
      ),
      repeating-conic-gradient(
        from 0deg,
        rgba(10, 10, 10, 0.6) 0% 25%,
        rgba(255, 255, 255, 0.7) 25% 50%
      );
    background-size:
      auto,
      12px 12px;
    background-position:
      0 0,
      0 0;
    box-shadow:
      0 1px 0 rgba(255, 255, 255, 0.44) inset,
      0 2px 2px rgba(12, 12, 12, 0.34),
      0 6px 14px rgba(10, 10, 10, 0.34);
    overflow: hidden;
    pointer-events: none;
    transform-origin: center;
    opacity: 0.88;
    filter: saturate(1.2) contrast(1.08);
  }

  :global(.washi-preview)::before,
  :global(.washi-strip)::before {
    content: "";
    position: absolute;
    inset: 0;
    background:
      repeating-linear-gradient(
        45deg,
        rgba(8, 8, 8, 0.3) 0,
        rgba(8, 8, 8, 0.3) 5px,
        rgba(255, 255, 255, 0) 6px,
        rgba(255, 255, 255, 0) 12px
      ),
      repeating-linear-gradient(
        -45deg,
        rgba(255, 255, 255, 0.34) 0,
        rgba(255, 255, 255, 0.34) 5px,
        rgba(255, 255, 255, 0) 6px,
        rgba(255, 255, 255, 0) 12px
      );
    opacity: 0.5;
  }

  :global(.washi-preview)::after,
  :global(.washi-strip)::after {
    content: "";
    position: absolute;
    inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.6' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.24'/%3E%3C/svg%3E");
    background-size: 120px 120px;
    opacity: 0.22;
    mix-blend-mode: multiply;
  }

  :global(.washi-preview) {
    position: fixed;
    left: 0;
    top: 0;
    width: 0;
    height: 0;
    z-index: 360;
    display: none;
    min-height: 20px;
    min-width: 22px;
  }

  :global(.washi-overlay) {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10050;
  }

  :global(.washi-strip) {
    position: absolute;
    left: 0;
    top: 0;
    z-index: 10051;
    min-height: 20px;
    min-width: 22px;
  }

  :global(.tape-seam) {
    position: absolute;
    inset: 0;
    z-index: 122;
    pointer-events: none;
    background:
      linear-gradient(
        90deg,
        transparent 0%,
        rgba(85, 66, 44, 0.34) 20%,
        rgba(80, 64, 42, 0.44) 50%,
        rgba(85, 66, 44, 0.34) 80%,
        transparent 100%
      );
    mix-blend-mode: multiply;
    opacity: 0.75;
  }

  /* ============================================ */
  /* TEAR ZONE (visual hint)                       */
  /* ============================================ */

  .tear-zone {
    position: relative;
    z-index: 5;
    padding: 4px 0;
  }

  /* Full-page cut line (fixed across viewport) */
  .page-cut-line {
    position: fixed;
    left: 0;
    top: 0;
    width: 0;
    height: 3px;
    background: linear-gradient(90deg,
      transparent 0%,
      rgba(200,180,160,0.15) 10%,
      rgba(200,180,160,0.35) 30%,
      rgba(220,200,180,0.5) 50%,
      rgba(200,180,160,0.35) 70%,
      rgba(200,180,160,0.15) 90%,
      transparent 100%
    );
    pointer-events: none;
    z-index: 200;
    display: none;
    transform: translateY(-50%);
    border-radius: 1px;
    box-shadow: 0 0 6px 1px rgba(200,180,160,0.15);
    transition: width 0.04s ease-out;
  }

  /* Pieces after tear */
  .receipt-piece {
    overflow: hidden !important;
  }

  /* Swipe affordance hint (matches sound-toggle vibe) */
  .cut-hint {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    bottom: calc(72px + env(safe-area-inset-bottom));
    font-family: var(--font-receipt);
    font-size: 14px;
    color: rgba(245, 240, 232, 0.5);
    letter-spacing: 1px;
    padding: 6px 14px;
    border: 1px solid rgba(245, 240, 232, 0.12);
    border-radius: 0;
    background: rgba(30, 28, 24, 0.85);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    pointer-events: none;
    z-index: 50;
    opacity: 0;
    transition: opacity 0.6s ease;
    white-space: nowrap;
  }

  .cut-hint.visible {
    opacity: 1;
    animation: cutHintPulse 2.5s ease-in-out infinite;
  }

  @keyframes cutHintPulse {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 1; }
  }

  /* ============================================ */
  /* CUT HANDLE (desktop draggable dot)            */
  /* ============================================ */

  /* ============================================ */
  /* CURSOR DOT (inverse blend, desktop only)      */
  /* ============================================ */

  .cursor-dot {
    position: fixed;
    width: 0;
    height: 0;
    pointer-events: none;
    z-index: 9999;
    mix-blend-mode: difference;
    opacity: 0;
    transition: opacity 0.15s;
    will-change: left, top;
  }

  .cursor-half {
    position: absolute;
    width: var(--dot-size, 8px);
    height: calc(var(--dot-size, 8px) / 2);
    background: white;
    pointer-events: none;
    transition: width 0.18s ease-out, height 0.18s ease-out, transform 0.18s ease-out;
  }

  .cursor-half-top {
    border-radius: calc(var(--dot-size, 8px) / 2) calc(var(--dot-size, 8px) / 2) 0 0;
    transform: translate(-50%, calc(-1 * var(--dot-size, 8px) / 2 + var(--split-offset, 0px)));
  }

  .cursor-half-bottom {
    border-radius: 0 0 calc(var(--dot-size, 8px) / 2) calc(var(--dot-size, 8px) / 2);
    transform: translate(-50%, calc(var(--split-offset-inv, 0px)));
  }

  /* Hide on touch devices and small screens */
  @media (pointer: coarse) {
    .cursor-dot { display: none; }
  }
  @media (max-width: 768px) {
    .cursor-dot { display: none; }
  }

  /* Hide OS cursor on desktop */
  @media (pointer: fine) {
    *, *::before, *::after {
      cursor: none !important;
    }
    :global(body.washi-mode) *, :global(body.washi-mode) *::before, :global(body.washi-mode) *::after {
      cursor: crosshair !important;
    }
  }

  /* ============================================ */
  /* RESPONSIVE                                    */
  /* ============================================ */

  @media (max-width: 440px) {
    .receipt {
      transform: rotate(0deg);
      padding: 20px 16px;
      width: 100%;
      box-shadow:
        0 1px 4px rgba(0,0,0,0.2),
        0 4px 16px rgba(0,0,0,0.15);
    }

    .receipt-line {
      font-size: 16px;
    }

    .receipt-line.big {
      font-size: 13px;
      font-weight: 900;
      letter-spacing: 1px;
    }

    .receipt-line.bold {
      font-size: 12px;
      font-weight: 800;
    }

    .receipt-line.divider {
      font-size: 12px;
      font-weight: 700;
    }
  }

  @media (max-width: 360px) {
    .receipt-line {
      font-size: 14px;
    }

    .receipt-line.big {
      font-size: 12px;
      font-weight: 900;
    }
  }
</style>

<script>
  // ============================================
  // RECEIPT PRINTER - CLIENT-SIDE LOGIC
  // ============================================

  document.addEventListener('DOMContentLoaded', () => {

    // ========================================
    // 1. SOUND ENGINE (tear sounds only)
    //    Primary: HTML5 Audio (reliable cross-browser)
    //    Enhanced: Web Audio API for zero-latency tear playback
    // ========================================
    class ReceiptSounds {
      private tearPool: HTMLAudioElement[] = [];
      private _enabled: boolean = true;
      private audioCtx: AudioContext | null = null;
      private tearBuffers: (AudioBuffer | null)[] = [null, null, null, null];
      private _unlocked: boolean = false;

      constructor() {
        // Restore saved sound preference
        const saved = localStorage.getItem('aw-sound-enabled');
        if (saved !== null) {
          this._enabled = saved === 'true';
        }
        // Create 2 copies of each tear sound for overlapping playback
        const tearFiles = ['/sounds/Tear-1.mp3', '/sounds/Tear-2.mp3', '/sounds/Tear-3.mp3', '/sounds/Tear-4.mp3'];
        tearFiles.forEach(file => {
          for (let copy = 0; copy < 2; copy++) {
            const a = new Audio(file);
            a.preload = 'auto';
            a.volume = 0.5;
            a.load();
            this.tearPool.push(a);
          }
        });

        // Web Audio API for zero-latency tear playback
        this._initWebAudio();

        // Unlock on first user interaction (autoplay policy)
        const unlock = () => {
          if (this._unlocked) return;
          this._unlocked = true;

          if (this.audioCtx?.state === 'suspended') {
            this.audioCtx.resume().then(() => this._decodeTearBuffers()).catch(() => {});
          }

          document.removeEventListener('click', unlock);
          document.removeEventListener('touchstart', unlock);
          document.removeEventListener('keydown', unlock);
        };
        document.addEventListener('click', unlock);
        document.addEventListener('touchstart', unlock);
        document.addEventListener('keydown', unlock);
      }

      private _initWebAudio() {
        try {
          this.audioCtx = new (window.AudioContext || (window as any).webkitAudioContext)();
          this._decodeTearBuffers();
        } catch(e) {}
      }

      private _decodeTearBuffers() {
        if (!this.audioCtx || this.audioCtx.state !== 'running') return;
        const tearFiles = ['/sounds/Tear-1.mp3', '/sounds/Tear-2.mp3', '/sounds/Tear-3.mp3', '/sounds/Tear-4.mp3'];
        tearFiles.forEach((file, idx) => {
          if (this.tearBuffers[idx]) return;
          fetch(file)
            .then(r => r.arrayBuffer())
            .then(buf => this.audioCtx!.decodeAudioData(buf))
            .then(decoded => { this.tearBuffers[idx] = decoded; })
            .catch(() => {});
        });
      }

      get isEnabled() { return this._enabled; }

      toggle() {
        this._enabled = !this._enabled;
        localStorage.setItem('aw-sound-enabled', this._enabled.toString());
        return this._enabled;
      }

      tearSound() {
        if (!this._enabled) return;

        // Try Web Audio API first (zero-latency, already decoded)
        if (this.audioCtx && this.audioCtx.state === 'running') {
          const available = this.tearBuffers.filter((b): b is AudioBuffer => b !== null);
          if (available.length > 0) {
            const buffer = available[Math.floor(Math.random() * available.length)];
            const source = this.audioCtx.createBufferSource();
            source.buffer = buffer;
            const gain = this.audioCtx.createGain();
            gain.gain.value = 0.5;
            source.connect(gain);
            gain.connect(this.audioCtx.destination);
            source.start(0);
            return;
          }
        }

        // If Web Audio context is suspended, try resuming for next time
        if (this.audioCtx && this.audioCtx.state === 'suspended') {
          this.audioCtx.resume().then(() => this._decodeTearBuffers()).catch(() => {});
        }

        // HTML5 Audio fallback: find a tear sound that isn't currently playing
        const startIdx = Math.floor(Math.random() * this.tearPool.length);
        for (let i = 0; i < this.tearPool.length; i++) {
          const audio = this.tearPool[(startIdx + i) % this.tearPool.length];
          if (audio.paused || audio.ended) {
            audio.currentTime = 0;
            audio.volume = 0.5;
            audio.play().catch(() => {});
            return;
          }
        }
        // All busy — force the first one to restart
        const audio = this.tearPool[startIdx];
        audio.currentTime = 0;
        audio.volume = 0.5;
        audio.play().catch(() => {});
      }
    }

    const sounds = new ReceiptSounds();

    // ========================================
    // 2. TOP-RIGHT CONTROLS
    // ========================================
    const soundToggle = document.getElementById('soundToggle')!;
    const soundIcon = document.getElementById('soundIcon')!;
    const tapeToggle = document.getElementById('tapeToggle') as HTMLButtonElement | null;
    const tapeIcon = document.getElementById('tapeIcon') as HTMLElement | null;
    const clearTapeBtn = document.getElementById('clearTape') as HTMLButtonElement | null;

    // Set initial state from saved preference
    const initialEnabled = sounds.isEnabled;
    soundIcon.textContent = initialEnabled ? '\u{1F50A}' : '\u{1F507}';
    soundToggle.classList.toggle('active', initialEnabled);
    let washiMode = false;

    function syncWashiToggle() {
      if (!tapeToggle) return;
      tapeToggle.classList.toggle('active', washiMode);
      document.body.classList.toggle('washi-mode', washiMode);
    }

    function toggleSound() {
      const enabled = sounds.toggle();
      soundIcon.textContent = enabled ? '\u{1F50A}' : '\u{1F507}';
      soundToggle.classList.toggle('active', enabled);
    }

    function clearAllTape() {
      document.querySelectorAll('.washi-strip').forEach(el => el.remove());
    }

    function flashButton(btn: HTMLElement | null) {
      if (!btn) return;
      btn.classList.add('toolbar-btn--pressed');
      setTimeout(() => btn.classList.remove('toolbar-btn--pressed'), 300);
    }

    soundToggle.addEventListener('click', toggleSound);

    tapeToggle?.addEventListener('click', () => {
      washiMode = !washiMode;
      syncWashiToggle();
    });

    clearTapeBtn?.addEventListener('click', clearAllTape);

    syncWashiToggle();

    // ========================================
    // 2b. DYNAMIC DATE & ORDER NUMBER
    // ========================================
    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, '0');
    const dateStr = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}`;
    const timeStr = `${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
    
    const receiptDateEl = document.getElementById('receiptDate');
    if (receiptDateEl) receiptDateEl.textContent = `${dateStr}  ${timeStr}`;

    // Order number: days since June 15, 1992
    const birthDate = new Date(1992, 5, 15);
    const daysAlive = Math.floor((now.getTime() - birthDate.getTime()) / (1000 * 60 * 60 * 24));
    const receiptOrderEl = document.getElementById('receiptOrder');
    if (receiptOrderEl) receiptOrderEl.textContent = daysAlive.toString();

    // Barcode number
    const barcodeNumberEl = document.getElementById('barcodeNumber');
    if (barcodeNumberEl) {
      const orderStr = daysAlive.toString().padStart(12, '0');
      barcodeNumberEl.textContent = `${orderStr.slice(0,4)} ${orderStr.slice(4,8)} ${orderStr.slice(8,12)}`;
    }

    // Visitor counter (Vercel KV/Redis)
    const visitorCountEl = document.getElementById('visitorCount');
    if (visitorCountEl) {
      const isNewSession = !sessionStorage.getItem('aw-session');

      // Clear old localStorage value
      localStorage.removeItem('aw-visitor-count');

      const endpoint = isNewSession
        ? '/api/visitor-count?increment=true'
        : '/api/visitor-count';

      fetch(endpoint)
        .then(res => res.json())
        .then(data => {
          const count = data.count || 0;
          visitorCountEl.textContent = count.toString().padStart(5, '0');

          if (isNewSession) {
            sessionStorage.setItem('aw-session', '1');
          }
        })
        .catch(() => {
          visitorCountEl.textContent = '00000';
        });
    }

    // ========================================
    // 3. FLOYD-STEINBERG DITHERING
    // ========================================
    function ditherImage(canvas: HTMLCanvasElement, imageSrc: string) {
      const ctx = canvas.getContext('2d')!;
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.src = imageSrc;

      img.onload = () => {
        // Target width for dithering (low-res for receipt look)
        const ditherWidth = 160;
        const ditherHeight = Math.round((img.height / img.width) * ditherWidth);

        canvas.width = ditherWidth;
        canvas.height = ditherHeight;

        // Draw source image scaled down
        ctx.drawImage(img, 0, 0, ditherWidth, ditherHeight);

        // Get image data
        const imageData = ctx.getImageData(0, 0, ditherWidth, ditherHeight);
        const data = imageData.data;

        // Convert to grayscale first
        for (let i = 0; i < data.length; i += 4) {
          const gray = data[i] * 0.299 + data[i+1] * 0.587 + data[i+2] * 0.114;
          data[i] = data[i+1] = data[i+2] = gray;
        }

        // Floyd-Steinberg dithering
        for (let y = 0; y < ditherHeight; y++) {
          for (let x = 0; x < ditherWidth; x++) {
            const idx = (y * ditherWidth + x) * 4;
            const oldVal = data[idx];
            const newVal = oldVal > 128 ? 255 : 0;
            const error = oldVal - newVal;

            data[idx] = data[idx+1] = data[idx+2] = newVal;

            // Distribute error to neighbors
            if (x + 1 < ditherWidth) {
              const i = (y * ditherWidth + x + 1) * 4;
              data[i] = data[i+1] = data[i+2] = clamp(data[i] + error * 7/16);
            }
            if (y + 1 < ditherHeight) {
              if (x - 1 >= 0) {
                const i = ((y+1) * ditherWidth + x - 1) * 4;
                data[i] = data[i+1] = data[i+2] = clamp(data[i] + error * 3/16);
              }
              {
                const i = ((y+1) * ditherWidth + x) * 4;
                data[i] = data[i+1] = data[i+2] = clamp(data[i] + error * 5/16);
              }
              if (x + 1 < ditherWidth) {
                const i = ((y+1) * ditherWidth + x + 1) * 4;
                data[i] = data[i+1] = data[i+2] = clamp(data[i] + error * 1/16);
              }
            }
          }
        }

        // Put dithered data back
        ctx.putImageData(imageData, 0, 0);

        // Convert canvas to <img> so cloneNode preserves the rendered image
        // (canvas pixel data is not cloned by cloneNode)
        const dataUrl = canvas.toDataURL('image/png');
        const replacement = document.createElement('img');
        replacement.src = dataUrl;
        replacement.alt = 'Andrew Washuta';
        replacement.className = 'portrait-img';
        canvas.replaceWith(replacement);
      };

      img.onerror = () => {
        // Fallback: just show a placeholder
        canvas.width = 160;
        canvas.height = 160;
        ctx.fillStyle = '#ede7d9';
        ctx.fillRect(0, 0, 160, 160);
        ctx.fillStyle = '#1a1a1a';
        ctx.font = '14px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('[PORTRAIT]', 80, 80);
      };
    }

    function clamp(val: number): number {
      return Math.min(255, Math.max(0, val));
    }

    // Initialize portrait dithering
    const portraitContainer = document.querySelector('.portrait-container') as HTMLElement;
    const canvas = document.getElementById('portraitCanvas') as HTMLCanvasElement;
    if (portraitContainer && canvas) {
      const src = portraitContainer.dataset.src;
      if (src) {
        ditherImage(canvas, src);
      }
    }

    // ========================================
    // 3b. BARCODE GENERATION
    // ========================================
    function generateBarcode(canvas: HTMLCanvasElement, value: number) {
      const ctx = canvas.getContext('2d')!;
      const w = canvas.width;
      const h = canvas.height;

      // Clear with paper color
      ctx.fillStyle = '#ede7d9';
      ctx.fillRect(0, 0, w, h);

      // Calculate total barcode width first to center it
      const seed = value.toString();
      const digits = seed.padStart(12, '0');
      const patterns = [
        [3,2,1,1], [2,2,2,1], [2,1,2,2], [1,4,1,1], [1,1,3,2],
        [1,2,3,1], [1,1,1,4], [1,3,1,2], [1,2,1,3], [3,1,1,2]
      ];

      let totalWidth = 8; // start guard: 3 bars + 2 spaces = 8px
      for (let d = 0; d < digits.length; d++) {
        const digit = parseInt(digits[d]);
        const pattern = patterns[digit];
        totalWidth += pattern.reduce((a, b) => a + b, 0) + 1; // pattern + 1px gap
        if (d === 5) totalWidth += 10; // middle guard
      }
      totalWidth += 8; // end guard

      const barHeight = h - 10;
      const startY = 5;
      let x = (w - totalWidth) / 2; // center the barcode

      ctx.fillStyle = '#1a1a1a';

      // Start guard pattern
      for (let g = 0; g < 3; g++) {
        ctx.fillRect(x, startY, 1, barHeight);
        x += 2;
      }
      x += 2;

      // Generate bars from order number digits
      for (let d = 0; d < digits.length; d++) {
        const digit = parseInt(digits[d]);
        const pattern = patterns[digit];
        for (let p = 0; p < pattern.length; p++) {
          if (p % 2 === 0) {
            ctx.fillRect(x, startY, pattern[p], barHeight);
          }
          x += pattern[p];
        }
        x += 1;

        // Middle guard
        if (d === 5) {
          x += 2;
          for (let g = 0; g < 3; g++) {
            ctx.fillRect(x, startY, 1, barHeight);
            x += 2;
          }
          x += 2;
        }
      }

      // End guard pattern
      x += 2;
      for (let g = 0; g < 3; g++) {
        ctx.fillRect(x, startY, 1, barHeight);
        x += 2;
      }
    }

    const barcodeCanvas = document.getElementById('barcodeCanvas') as HTMLCanvasElement;
    if (barcodeCanvas) {
      generateBarcode(barcodeCanvas, daysAlive);

      // Convert canvas to <img> so cloneNode preserves the rendered barcode
      // (canvas pixel data is not cloned by cloneNode)
      const barcodeDataUrl = barcodeCanvas.toDataURL('image/png');
      const barcodeImg = document.createElement('img');
      barcodeImg.src = barcodeDataUrl;
      barcodeImg.alt = 'Barcode';
      barcodeImg.id = barcodeCanvas.id;
      barcodeImg.width = barcodeCanvas.width;
      barcodeImg.height = barcodeCanvas.height;
      barcodeCanvas.replaceWith(barcodeImg);
    }

    // ========================================
    // 3c. RANDOM PRINT ARTIFACTS
    // ========================================
    // Add subtle horizontal misalignment to ~15% of lines for authenticity
    const allLines = document.querySelectorAll('.receipt-line') as NodeListOf<HTMLElement>;
    allLines.forEach((line) => {
      if (Math.random() < 0.12) {
        const offset = (Math.random() - 0.5) * 1.2; // -0.6 to +0.6 px
        line.style.transform = `translateX(${offset}px)`;
      }
    });

    // ========================================
    // 4. PRINTING ANIMATION
    // ========================================
    const allPrintables = document.querySelectorAll('[data-print]') as NodeListOf<HTMLElement>;
    let printIndex = 0;
    let isPrinting = false;
    let printTimeout: ReturnType<typeof setTimeout> | null = null;
    const MIN_LINES_BEFORE_CUT = 8;
    function canCutDuringPrint(): boolean {
      return !isPrinting || printIndex >= MIN_LINES_BEFORE_CUT;
    }

    // Callback set by tear system to mirror class changes to clone pieces
    let mirrorPrintState: ((index: number, addClasses: string[], removeClasses: string[]) => void) | null = null;

    function printNextLine() {
      if (printIndex >= allPrintables.length) {
        finishPrinting();
        return;
      }

      const line = allPrintables[printIndex];

      // Remove cursor from previous line
      if (printIndex > 0) {
        allPrintables[printIndex - 1].classList.remove('printing');
        mirrorPrintState?.(printIndex - 1, [], ['printing']);
      }

      // Print this line
      line.classList.add('printed');
      line.classList.add('printing');
      mirrorPrintState?.(printIndex, ['printed', 'printing'], []);

      printIndex++;

      // Show cut hint once early cutting is available
      if (printIndex === MIN_LINES_BEFORE_CUT) {
        setTimeout(showCutHint, 800);
      }

      // Vary delay for different line types for authentic feel
      let delay = 40;
      const text = line.textContent || '';

      if (text.includes('====') || text.includes('----')) {
        delay = 55;
      } else if (line.classList.contains('spacer') || text.trim() === '') {
        delay = 12;
      } else if (line.classList.contains('big')) {
        delay = 70;
      } else if (line.classList.contains('portrait-container') || line.classList.contains('barcode-container')) {
        delay = 350;
      } else if (line.classList.contains('bold')) {
        delay = 50;
      }

      printTimeout = setTimeout(printNextLine, delay);
    }

    // ========================================
    // CUT HINT / SWIPE AFFORDANCE
    // ========================================
    let cutHintEl: HTMLElement | null = null;
    let cutHintTimer: ReturnType<typeof setTimeout> | null = null;

    function showCutHint() {
      // Always show on first visit (cleared localStorage key)
      if (sessionStorage.getItem('aw-hint-shown')) return;
      sessionStorage.setItem('aw-hint-shown', '1');

      cutHintEl = document.createElement('div');
      cutHintEl.className = 'cut-hint';
      cutHintEl.textContent = window.matchMedia('(pointer: fine)').matches
        ? '[ CLICK & DRAG TO TEAR ]'
        : '[ SWIPE TO TEAR ]';
      document.body.appendChild(cutHintEl);

      // Force reflow before adding class so transition fires
      cutHintEl.getBoundingClientRect();

      // Fade in after brief pause
      setTimeout(() => {
        if (cutHintEl) cutHintEl.classList.add('visible');
      }, 600);

      // Auto-dismiss after 8 seconds
      cutHintTimer = setTimeout(() => {
        if (cutHintEl) {
          cutHintEl.classList.remove('visible');
          setTimeout(() => { cutHintEl?.remove(); cutHintEl = null; }, 600);
        }
      }, 8000);
    }

    function dismissCutHint() {
      if (cutHintTimer) { clearTimeout(cutHintTimer); cutHintTimer = null; }
      if (cutHintEl) {
        cutHintEl.classList.remove('visible');
        setTimeout(() => { cutHintEl?.remove(); cutHintEl = null; }, 600);
      }
    }

    function finishPrinting() {
      isPrinting = false;

      // Remove any remaining cursor
      allPrintables.forEach(el => el.classList.remove('printing'));

      // Mirror cursor removal to clones
      for (let i = 0; i < allPrintables.length; i++) {
        mirrorPrintState?.(i, [], ['printing']);
      }

    }

    function startPrinting() {
      if (isPrinting) return;
      isPrinting = true;

      // Small delay for feel, then begin line-by-line animation
      printTimeout = setTimeout(printNextLine, 200);
    }

    // ========================================
    // 5. RANDOM ROTATION (subtle authenticity)
    // ========================================
    const receipt = document.getElementById('receipt');
    if (receipt) {
      const rotation = -0.8 + Math.random() * 1.6; // -0.8 to +0.8 degrees
      receipt.style.transform = `rotate(${rotation}deg)`;
    }

    // ========================================
    // 5b. CURSOR DOT (inverse blend, desktop only)
    //     with lerp/inertia for trailing lag
    // ========================================
    const cursorDot = document.getElementById('cursorDot');
    const cursorHalfTop = cursorDot?.querySelector('.cursor-half-top') as HTMLElement | null;
    const cursorHalfBottom = cursorDot?.querySelector('.cursor-half-bottom') as HTMLElement | null;
    let dotTargetX = 0;
    let dotTargetY = 0;
    let dotCurrentX = 0;
    let dotCurrentY = 0;
    let dotVisible = false;
    let dotAnimating = false;
    const DOT_LERP = 0.18;
    const DOT_SIZE_MIN = 8;
    const DOT_SIZE_MAX = 16;
    const PROXIMITY_RANGE = 80;
    const SPLIT_GAP = 1;
    const CUT_EDGE_SAFETY = 10;
    const CUT_EDGE_PADDING = 30;

    if (cursorDot && window.matchMedia('(pointer: fine)').matches) {
      document.addEventListener('mousemove', (e: MouseEvent) => {
        dotTargetX = e.clientX;
        dotTargetY = e.clientY;

        if (!dotVisible) {
          dotCurrentX = dotTargetX;
          dotCurrentY = dotTargetY;
          cursorDot.style.left = dotCurrentX + 'px';
          cursorDot.style.top = dotCurrentY + 'px';
          cursorDot.style.opacity = '1';
          dotVisible = true;
        }

        if (!dotAnimating) {
          dotAnimating = true;
          requestAnimationFrame(dotLerp);
        }
      });

      function dotLerp() {
        dotCurrentX += (dotTargetX - dotCurrentX) * DOT_LERP;
        dotCurrentY += (dotTargetY - dotCurrentY) * DOT_LERP;

        cursorDot!.style.left = dotCurrentX + 'px';
        cursorDot!.style.top = dotCurrentY + 'px';

        const dx = Math.abs(dotTargetX - dotCurrentX);
        const dy = Math.abs(dotTargetY - dotCurrentY);
        if (dx > 0.5 || dy > 0.5) {
          requestAnimationFrame(dotLerp);
        } else {
          dotCurrentX = dotTargetX;
          dotCurrentY = dotTargetY;
          cursorDot!.style.left = dotCurrentX + 'px';
          cursorDot!.style.top = dotCurrentY + 'px';
          dotAnimating = false;
        }
      }

      document.addEventListener('mouseleave', () => {
        cursorDot.style.opacity = '0';
        dotVisible = false;
        dotAnimating = false;
      });
    }

    // ========================================
    // 6. TEAR INTERACTION
    //    - Swipe horizontally ANYWHERE on the page
    //    - Multiple tears allowed
    //    - Pieces separate and stay visible
    // ========================================

    if (receipt) {
      const TEAR_GAP = 22; // px of separation per tear

      // Each piece tracks its clip bounds, offset, and torn edges
      type JaggedEdge = number[]; // y-offset values in px, evenly spaced across width

      type TearPiece = {
        el: HTMLElement;
        top: number;      // 0-100% content start
        bottom: number;   // 0-100% content end
        offsetY: number;  // accumulated px offset
        rotation: number; // accumulated rotation offset (degrees)
        topEdge: JaggedEdge | null;    // jagged tear data (null = straight)
        bottomEdge: JaggedEdge | null; // jagged tear data (null = straight)
        printables: HTMLElement[];     // cached [data-print] elements in this clone
      };

      let pieces: TearPiece[] = [];
      let tearSystemReady = false;
      let baseRotation = 0;
      let receiptH = 0;
      const desktopFinePointer = window.matchMedia('(pointer: fine)').matches;

      type TapeStroke = {
        startX: number;
        startY: number;
        endX: number;
        endY: number;
      };

      let washiDrawing = false;
      let washiStartX = 0;
      let washiStartY = 0;
      let washiCurrentX = 0;
      let washiCurrentY = 0;
      const usePointerWashi = typeof window !== 'undefined' && 'PointerEvent' in window;
      let activeWashiPointerId: number | null = null;
      const MIN_WASHI_STROKE = 10;
      let washiPreviewClip = 'polygon(0% 0%, 0% 100%, 100% 100%, 100% 0%)';
      const washiPreview = document.createElement('div');
      washiPreview.className = 'washi-preview';
      const washiOverlay = document.createElement('div');
      washiOverlay.className = 'washi-overlay';
      const receiptWrapper = receipt!.parentElement as HTMLElement;
      if (getComputedStyle(receiptWrapper).position === 'static') {
        receiptWrapper.style.position = 'relative';
      }
      Object.assign(washiOverlay.style, {
        position: 'absolute',
        left: '0',
        top: '0',
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
        zIndex: '10050',
      });
      receiptWrapper.appendChild(washiOverlay);
      document.body.appendChild(washiPreview);

      function clampPct(v: number, min: number, max: number): number {
        return Math.max(min, Math.min(max, v));
      }

      function createWashiClipPath(): string {
        const segments = 7;
        let s = Math.floor(Math.random() * 2147483647) || 17;
        const rand = () => {
          s = (s * 48271) % 2147483647;
          return s / 2147483647;
        };

        const left: string[] = [];
        const right: string[] = [];
        for (let i = 0; i <= segments; i++) {
          const y = (i / segments) * 100;
          const lx = 1.2 + rand() * 6.5;
          const rx = 98.8 - rand() * 6.5;
          left.push(`${lx.toFixed(2)}% ${y.toFixed(2)}%`);
          right.push(`${rx.toFixed(2)}% ${y.toFixed(2)}%`);
        }
        right.reverse();
        return `polygon(${left.join(', ')}, ${right.join(', ')})`;
      }

      function hideWashiPreview() {
        washiPreview.style.display = 'none';
        washiPreview.style.width = '0';
      }

      function updateWashiPreview() {
        const dx = washiCurrentX - washiStartX;
        const dy = washiCurrentY - washiStartY;
        const len = Math.hypot(dx, dy);
        if (len < 2) {
          hideWashiPreview();
          return;
        }

        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        const midX = (washiStartX + washiCurrentX) / 2;
        const midY = (washiStartY + washiCurrentY) / 2;

        washiPreview.style.display = 'block';
        washiPreview.style.left = `${midX}px`;
        washiPreview.style.top = `${midY}px`;
        washiPreview.style.width = `${len + 12}px`;
        washiPreview.style.height = `${20}px`;
        washiPreview.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
        washiPreview.style.clipPath = washiPreviewClip;
      }

      // Wire up print state mirroring to clone pieces
      mirrorPrintState = (index, addClasses, removeClasses) => {
        if (!tearSystemReady) return;
        for (const piece of pieces) {
          const target = piece.printables[index];
          if (!target) continue;
          for (const cls of addClasses) target.classList.add(cls);
          for (const cls of removeClasses) target.classList.remove(cls);
        }
      };

      // Generate irregular jagged edge simulating perforated paper tear
      function generateJaggedEdge(): JaggedEdge {
        const numPoints = 80;
        const edge: number[] = [];
        for (let i = 0; i <= numPoints; i++) {
          const t = i / numPoints;
          // Organic waviness from overlapping sine waves
          const wave = Math.sin(t * Math.PI * 6) * 1.2
                     + Math.sin(t * Math.PI * 13 + 1.7) * 0.8;
          // Random teeth: 2-4px irregular triangular variations
          const tooth = (Math.random() - 0.5) * 5;
          edge.push(wave + tooth);
        }
        return edge;
      }

      // Convert jagged edge data to polygon point strings
      function jaggedPoints(edge: JaggedEdge, basePct: number, reverse: boolean): string {
        const pts = edge.map((yPx, i) => {
          const x = (i / (edge.length - 1)) * 100;
          const y = basePct + (yPx / receiptH) * 100;
          return `${x.toFixed(2)}% ${y.toFixed(2)}%`;
        });
        if (reverse) pts.reverse();
        return pts.join(', ');
      }

      // Full-viewport cut line
      const pageCutLine = document.createElement('div');
      pageCutLine.className = 'page-cut-line';
      document.body.appendChild(pageCutLine);

      // Build clip-path polygon for a piece, with jagged edges at tear points
      function clipFor(p: TearPiece): string {
        // Top edge (left to right)
        let topStr: string;
        if (p.topEdge) {
          topStr = jaggedPoints(p.topEdge, p.top, false);
        } else {
          const t = p.top === 0 ? -2 : p.top;
          topStr = `0% ${t}%, 100% ${t}%`;
        }

        // Bottom edge (right to left)
        let botStr: string;
        if (p.bottomEdge) {
          botStr = jaggedPoints(p.bottomEdge, p.bottom, true);
        } else {
          const b = p.bottom === 100 ? 102 : p.bottom;
          botStr = `100% ${b}%, 0% ${b}%`;
        }

        return `polygon(${topStr}, ${botStr})`;
      }

      function transformFor(p: TearPiece): string {
        return `translateX(-50%) rotate(${baseRotation + p.rotation}deg) translateY(${p.offsetY}px)`;
      }

      const PIECE_SHADOW = 'drop-shadow(0 2px 4px rgba(0,0,0,0.1)) drop-shadow(0 4px 12px rgba(0,0,0,0.12))';

      // Lazily set up the piece system on the first tear
      function initTearSystem() {
        if (tearSystemReady) return;
        tearSystemReady = true;

        const wrapper = receipt!.parentElement!;
        wrapper.style.position = 'relative';

        // Capture the current rotation and height
        const m = receipt!.style.transform?.match(/rotate\(([^)]+)deg\)/);
        baseRotation = m ? parseFloat(m[1]) : 0;
        receiptH = receipt!.offsetHeight;

        // Create the initial full-receipt piece
        const { el, printables } = makePieceEl(0, 100, 0, 0, null, null);
        wrapper.appendChild(el);
        pieces.push({ el, top: 0, bottom: 100, offsetY: 0, rotation: 0, topEdge: null, bottomEdge: null, printables });

        // Hide the original (it stays in flow for layout height)
        receipt!.style.visibility = 'hidden';
        receipt!.style.boxShadow = 'none';
        receipt!.style.filter = 'none';
      }

      // ---- Canvas-generated paper fiber noise textures ----
      // Generates a unique, high-contrast noise strip that looks like
      // torn thermal paper fibers: irregular dots, streaks, and grain

      function generateFiberTexture(width: number, height: number, seed: number): string {
        const c = document.createElement('canvas');
        c.width = width;
        c.height = height;
        const ctx = c.getContext('2d')!;

        // Start with transparent
        ctx.clearRect(0, 0, width, height);

        // Seeded pseudo-random for reproducibility within a tear
        let s = seed;
        const rand = () => { s = (s * 16807 + 0) % 2147483647; return (s & 0x7fffffff) / 0x7fffffff; };

        const imgData = ctx.createImageData(width, height);
        const d = imgData.data;

        // Layer 1: Base noise — random grayscale speckle
        for (let i = 0; i < d.length; i += 4) {
          const px = (i / 4) % width;
          const py = Math.floor((i / 4) / width);
          const centerDist = Math.abs(py - height / 2) / (height / 2);

          // Stronger noise near the center (the tear line), fading at edges
          const edgeFade = 1 - centerDist * centerDist;
          const noiseVal = rand();

          // High-contrast binary noise with some mid-tones
          let gray: number;
          if (noiseVal < 0.35 * edgeFade) {
            gray = 40 + rand() * 60; // dark speckles
          } else if (noiseVal < 0.5 * edgeFade) {
            gray = 120 + rand() * 50; // mid-tone grain
          } else {
            gray = 0; // transparent (will be set via alpha)
          }

          const alpha = noiseVal < 0.5 * edgeFade ? (180 * edgeFade + rand() * 75) : 0;
          d[i] = gray;
          d[i + 1] = gray;
          d[i + 2] = gray;
          d[i + 3] = Math.min(255, alpha);

          // Occasional horizontal fiber streaks
          if (rand() < 0.008 * edgeFade) {
            const streakLen = 3 + Math.floor(rand() * 8);
            const streakGray = 30 + rand() * 70;
            for (let sx = 0; sx < streakLen && px + sx < width; sx++) {
              const si = ((py * width) + px + sx) * 4;
              d[si] = streakGray;
              d[si + 1] = streakGray;
              d[si + 2] = streakGray;
              d[si + 3] = Math.min(255, 160 * edgeFade + rand() * 90);
            }
          }
        }
        ctx.putImageData(imgData, 0, 0);

        // Layer 2: Scattered larger fiber clumps
        for (let i = 0; i < 20; i++) {
          const fx = rand() * width;
          const fy = height * 0.3 + rand() * height * 0.4;
          const fw = 1 + rand() * 4;
          const fh = 1 + rand() * 2;
          const fAlpha = 0.15 + rand() * 0.35;
          ctx.fillStyle = `rgba(${50 + rand() * 60}, ${40 + rand() * 50}, ${30 + rand() * 40}, ${fAlpha})`;
          ctx.fillRect(fx, fy, fw, fh);
        }

        return c.toDataURL('image/png');
      }

      // Pre-generate a few textures to avoid re-creating per tear
      let tearTextureCache: string[] = [];
      function getTearTexture(seed: number): string {
        const idx = seed % 6;
        if (!tearTextureCache[idx]) {
          tearTextureCache[idx] = generateFiberTexture(400, 24, seed * 7919 + idx * 1301);
        }
        return tearTextureCache[idx];
      }
      let tearCounter = 0;

      function addEdgeGrain(parent: HTMLElement, yPct: number, side: 'top' | 'bottom') {
        tearCounter++;
        const tex1 = getTearTexture(tearCounter);
        const tex2 = getTearTexture(tearCounter + 100);

        // Gradient mask: texture is fully opaque at the tear line and
        // fades to transparent as it moves away into clean paper.
        // 'top' side = torn edge is at the bottom of this piece → fade upward
        // 'bottom' side = torn edge is at the top of this piece → fade downward
        const maskTop = side === 'top'
          ? 'linear-gradient(to top, rgba(0,0,0,1) 0%, rgba(0,0,0,0.6) 35%, rgba(0,0,0,0) 100%)'
          : 'linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,0.6) 35%, rgba(0,0,0,0) 100%)';

        // Layer 1: Main fiber texture — pronounced, multiply blend
        const grain = document.createElement('div');
        Object.assign(grain.style, {
          position: 'absolute',
          left: '-3px',
          right: '-3px',
          top: `${yPct}%`,
          height: '20px',
          transform: 'translateY(-50%)',
          backgroundImage: `url(${tex1})`,
          backgroundSize: '400px 24px',
          backgroundRepeat: 'repeat-x',
          mixBlendMode: 'multiply',
          opacity: '0.6',
          pointerEvents: 'none',
          zIndex: '99',
          WebkitMaskImage: maskTop,
          maskImage: maskTop,
        });
        parent.appendChild(grain);

        // Layer 2: Offset texture for depth — darken blend, shifted
        const depth = document.createElement('div');
        Object.assign(depth.style, {
          position: 'absolute',
          left: '-2px',
          right: '-2px',
          top: `${yPct}%`,
          height: '14px',
          transform: 'translateY(-50%) translateX(3px)',
          backgroundImage: `url(${tex2})`,
          backgroundSize: '350px 24px',
          backgroundRepeat: 'repeat-x',
          mixBlendMode: 'darken',
          opacity: '0.4',
          pointerEvents: 'none',
          zIndex: '100',
          WebkitMaskImage: maskTop,
          maskImage: maskTop,
        });
        parent.appendChild(depth);

        // Layer 3: Color-tinted edge line — warm brown tint at tear
        const tint = document.createElement('div');
        Object.assign(tint.style, {
          position: 'absolute',
          left: '-1px',
          right: '-1px',
          top: `${yPct}%`,
          height: '3px',
          transform: 'translateY(-50%)',
          background: 'linear-gradient(90deg, transparent, rgba(140,110,70,0.12) 20%, rgba(160,130,80,0.18) 50%, rgba(140,110,70,0.12) 80%, transparent)',
          pointerEvents: 'none',
          zIndex: '101',
        });
        parent.appendChild(tint);
      }

      function makePieceEl(top: number, bottom: number, offsetY: number, rot: number, topEdge: JaggedEdge | null = null, bottomEdge: JaggedEdge | null = null): { el: HTMLElement; printables: HTMLElement[] } {
        const clone = receipt!.cloneNode(true) as HTMLElement;
        clone.removeAttribute('id');
        clone.classList.add('receipt-piece');
        const p = { top, bottom, offsetY, rotation: rot, topEdge, bottomEdge, printables: [] } as TearPiece;
        Object.assign(clone.style, {
          position: 'absolute',
          top: '0',
          left: '50%',
          width: receipt!.offsetWidth + 'px',
          margin: '0',
          visibility: 'visible',
          clipPath: clipFor(p),
          boxShadow: 'none',
          filter: PIECE_SHADOW,
          contain: 'layout paint style',
          backfaceVisibility: 'hidden',
          willChange: 'clip-path, transform',
          transform: transformFor(p),
          transformOrigin: 'center center',
          pointerEvents: 'none',
          zIndex: '10',
          overflow: 'hidden',
          transition: 'none',
        });

        // Add paper-fiber grain texture at torn edges
        // 'bottom' side = this piece's torn top edge (fibers fade downward into paper)
        // 'top' side = this piece's torn bottom edge (fibers fade upward into paper)
        if (topEdge) addEdgeGrain(clone, top, 'bottom');
        if (bottomEdge) addEdgeGrain(clone, bottom, 'top');

        const printables = Array.from(clone.querySelectorAll('[data-print]')) as HTMLElement[];
        return { el: clone, printables };
      }

      function seamClipPath(edge: JaggedEdge, basePct: number): string {
        const halfThicknessPx = 1.0;
        const topPoints: string[] = [];
        const bottomPoints: string[] = [];
        for (let i = 0; i < edge.length; i++) {
          const x = (i / (edge.length - 1)) * 100;
          const topY = basePct + ((edge[i] - halfThicknessPx) / receiptH) * 100;
          const bottomY = basePct + ((edge[i] + halfThicknessPx) / receiptH) * 100;
          topPoints.push(`${x.toFixed(2)}% ${topY.toFixed(2)}%`);
          bottomPoints.push(`${x.toFixed(2)}% ${bottomY.toFixed(2)}%`);
        }
        bottomPoints.reverse();
        return `polygon(${topPoints.join(', ')}, ${bottomPoints.join(', ')})`;
      }

      function addSeamTrace(parent: HTMLElement, edge: JaggedEdge, seamYPct: number) {
        const seam = document.createElement('div');
        seam.className = 'tape-seam';
        seam.dataset.seamY = seamYPct.toFixed(3);
        seam.style.clipPath = seamClipPath(edge, seamYPct);
        parent.appendChild(seam);
      }

      function addWashiStrip(parent: HTMLElement, stroke: TapeStroke, seamYPct: number, pieceAngleDeg: number) {
        const rr = receipt!.getBoundingClientRect();
        if (rr.width < 1 || rr.height < 1) return;

        const startXPct = ((stroke.startX - rr.left) / rr.width) * 100;
        const endXPct = ((stroke.endX - rr.left) / rr.width) * 100;
        const centerXPct = clampPct((startXPct + endXPct) / 2, -12, 112);
        const widthPct = clampPct(Math.abs(endXPct - startXPct) + 14, 22, 110);
        const rawAngle = Math.atan2(stroke.endY - stroke.startY, stroke.endX - stroke.startX) * (180 / Math.PI);
        const relativeAngle = rawAngle - pieceAngleDeg;

        const strip = document.createElement('div');
        strip.className = 'washi-strip';
        strip.dataset.seamY = seamYPct.toFixed(3);
        strip.style.left = `${centerXPct}%`;
        strip.style.top = `${seamYPct.toFixed(3)}%`;
        strip.style.width = `${widthPct.toFixed(3)}%`;
        strip.style.height = `${(18 + Math.random() * 8).toFixed(2)}px`;
        strip.style.transform = `translate(-50%, -50%) rotate(${relativeAngle.toFixed(3)}deg)`;
        strip.style.clipPath = createWashiClipPath();
        strip.style.setProperty('--washi-alpha', (0.80 + Math.random() * 0.12).toFixed(2));
        parent.appendChild(strip);
      }

      function addFreeWashiStrip(stroke: TapeStroke) {
        const dx = stroke.endX - stroke.startX;
        const dy = stroke.endY - stroke.startY;
        const len = Math.hypot(dx, dy);
        if (len < 2) return;

        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        const overlayRect = washiOverlay.getBoundingClientRect();
        const midX = (stroke.startX + stroke.endX) / 2 - overlayRect.left;
        const midY = (stroke.startY + stroke.endY) / 2 - overlayRect.top;
        if (!Number.isFinite(midX) || !Number.isFinite(midY)) return;

        const strip = document.createElement('div');
        strip.className = 'washi-strip';
        strip.style.left = `${midX.toFixed(2)}px`;
        strip.style.top = `${midY.toFixed(2)}px`;
        strip.style.width = `${(len + 12).toFixed(2)}px`;
        strip.style.height = `${(18 + Math.random() * 8).toFixed(2)}px`;
        strip.style.transform = `translate(-50%, -50%) rotate(${angle.toFixed(3)}deg)`;
        strip.style.clipPath = createWashiClipPath();
        strip.style.setProperty('--washi-alpha', (0.80 + Math.random() * 0.12).toFixed(2));
        washiOverlay.appendChild(strip);
      }

      function pointToSegmentDistance(
        px: number,
        py: number,
        x1: number,
        y1: number,
        x2: number,
        y2: number,
      ): number {
        const vx = x2 - x1;
        const vy = y2 - y1;
        const wx = px - x1;
        const wy = py - y1;
        const c1 = vx * wx + vy * wy;
        if (c1 <= 0) return Math.hypot(px - x1, py - y1);
        const c2 = vx * vx + vy * vy;
        if (c2 <= c1) return Math.hypot(px - x2, py - y2);
        const b = c1 / c2;
        const bx = x1 + b * vx;
        const by = y1 + b * vy;
        return Math.hypot(px - bx, py - by);
      }

      function strokeCrossesHorizontalSeam(
        stroke: TapeStroke,
        seamY: number,
        seamLeft: number,
        seamRight: number,
      ): boolean {
        const y1 = stroke.startY;
        const y2 = stroke.endY;
        const x1 = stroke.startX;
        const x2 = stroke.endX;
        const dy = y2 - y1;
        if (Math.abs(dy) < 0.001) return false;
        const t = (seamY - y1) / dy;
        if (t < 0 || t > 1) return false;
        const xAtSeam = x1 + (x2 - x1) * t;
        return xAtSeam >= seamLeft - 26 && xAtSeam <= seamRight + 26;
      }

      function strokeIntersectsSeamBand(
        stroke: TapeStroke,
        seamY: number,
        seamLeft: number,
        seamRight: number,
      ): boolean {
        const sxMin = Math.min(stroke.startX, stroke.endX);
        const sxMax = Math.max(stroke.startX, stroke.endX);
        const syMin = Math.min(stroke.startY, stroke.endY);
        const syMax = Math.max(stroke.startY, stroke.endY);
        const bandPadX = 34;
        const bandPadY = 34;

        const overlapsBandBox =
          sxMax >= seamLeft - bandPadX &&
          sxMin <= seamRight + bandPadX &&
          syMax >= seamY - bandPadY &&
          syMin <= seamY + bandPadY;
        if (!overlapsBandBox) return false;

        if (strokeCrossesHorizontalSeam(stroke, seamY, seamLeft, seamRight)) return true;

        const midX = (stroke.startX + stroke.endX) / 2;
        const midY = (stroke.startY + stroke.endY) / 2;
        const nearX = midX >= seamLeft - bandPadX && midX <= seamRight + bandPadX;
        const nearY = Math.abs(midY - seamY) <= bandPadY;
        return nearX && nearY;
      }

      function getSeamGeometry(topPiece: TearPiece, bottomPiece: TearPiece) {
        const rr = receipt!.getBoundingClientRect();
        const rh = rr.height;
        const topVisibleBottom = rr.top + (topPiece.bottom / 100) * rh + topPiece.offsetY;
        const bottomVisibleTop = rr.top + (bottomPiece.top / 100) * rh + bottomPiece.offsetY;
        return {
          seamY: (topVisibleBottom + bottomVisibleTop) / 2,
          seamLeft: rr.left - 20,
          seamRight: rr.right + 20,
        };
      }

      function findSeamIndexForStroke(stroke: TapeStroke): number {
        if (!tearSystemReady || pieces.length < 2) return -1;
        const dx = stroke.endX - stroke.startX;
        const dy = stroke.endY - stroke.startY;
        const length = Math.hypot(dx, dy);
        if (length < 10) return -1;
        const midX = (stroke.startX + stroke.endX) / 2;
        const midY = (stroke.startY + stroke.endY) / 2;

        let bestIdx = -1;
        let bestScore = Infinity;
        for (let i = 0; i < pieces.length - 1; i++) {
          const topPiece = pieces[i];
          const bottomPiece = pieces[i + 1];

          const { seamY, seamLeft, seamRight } = getSeamGeometry(topPiece, bottomPiece);
          if (seamRight <= seamLeft) continue;
          if (!strokeIntersectsSeamBand(stroke, seamY, seamLeft, seamRight)) continue;

          const probeX = clampPct(midX, seamLeft, seamRight);
          const distMid = pointToSegmentDistance(
            probeX,
            seamY,
            stroke.startX,
            stroke.startY,
            stroke.endX,
            stroke.endY,
          );
          const distLeft = pointToSegmentDistance(
            seamLeft,
            seamY,
            stroke.startX,
            stroke.startY,
            stroke.endX,
            stroke.endY,
          );
          const distRight = pointToSegmentDistance(
            seamRight,
            seamY,
            stroke.startX,
            stroke.startY,
            stroke.endX,
            stroke.endY,
          );
          const distToStroke = Math.min(distMid, distLeft, distRight);
          const seamOffsetPenalty = Math.abs(midY - seamY) * 0.35;
          const verticalBonus = Math.abs(dy) > Math.abs(dx) * 0.85 ? -10 : 0;
          const score = distToStroke + seamOffsetPenalty + verticalBonus;
          if (score < bestScore) {
            bestScore = score;
            bestIdx = i;
          }
        }
        if (bestScore > 140) return -1;
        return bestIdx;
      }

      function findNearestSeamByMidpoint(stroke: TapeStroke): number {
        if (!tearSystemReady || pieces.length < 2) return -1;
        const midX = (stroke.startX + stroke.endX) / 2;
        const midY = (stroke.startY + stroke.endY) / 2;
        const rr = receipt!.getBoundingClientRect();
        if (midX < rr.left - 90 || midX > rr.right + 90) return -1;

        let bestIdx = -1;
        let bestDist = Infinity;
        for (let i = 0; i < pieces.length - 1; i++) {
          const { seamY } = getSeamGeometry(pieces[i], pieces[i + 1]);
          const dist = Math.abs(midY - seamY);
          if (dist < bestDist) {
            bestDist = dist;
            bestIdx = i;
          }
        }
        if (bestDist > 110) return -1;
        return bestIdx;
      }

      function mergePiecesAt(topIdx: number, stroke: TapeStroke | null): boolean {
        if (topIdx < 0 || topIdx >= pieces.length - 1) return false;

        const topPiece = pieces[topIdx];
        const bottomPiece = pieces[topIdx + 1];
        const seamEdge = topPiece.bottomEdge || bottomPiece.topEdge || generateJaggedEdge();

        const wrapper = receipt!.parentElement!;
        const mergedTop = topPiece.top;
        const mergedBottom = bottomPiece.bottom;
        const seamYPct = (topPiece.bottom + bottomPiece.top) / 2;
        const mergedOffsetY = topPiece.offsetY;
        const mergedRotation = (topPiece.rotation + bottomPiece.rotation) / 2;
        const mergedTopEdge = topPiece.topEdge;
        const mergedBottomEdge = bottomPiece.bottomEdge;

        const { el: mergedEl, printables: mergedPrintables } = makePieceEl(
          mergedTop,
          mergedBottom,
          mergedOffsetY,
          mergedRotation,
          mergedTopEdge,
          mergedBottomEdge,
        );
        const nextEl = pieces[topIdx + 2]?.el;
        if (nextEl) wrapper.insertBefore(mergedEl, nextEl);
        else wrapper.appendChild(mergedEl);

        if (stroke) addWashiStrip(mergedEl, stroke, seamYPct, baseRotation + mergedRotation);
        addSeamTrace(mergedEl, seamEdge, seamYPct);

        // Transfer existing seam traces and washi strips from old pieces to merged element
        for (const child of [...topPiece.el.querySelectorAll(':scope > .tape-seam, :scope > .washi-strip')]) {
          mergedEl.appendChild(child);
        }
        for (const child of [...bottomPiece.el.querySelectorAll(':scope > .tape-seam, :scope > .washi-strip')]) {
          mergedEl.appendChild(child);
        }

        topPiece.el.remove();
        bottomPiece.el.remove();

        const mergedPiece: TearPiece = {
          el: mergedEl,
          top: mergedTop,
          bottom: mergedBottom,
          offsetY: mergedOffsetY,
          rotation: mergedRotation,
          topEdge: mergedTopEdge,
          bottomEdge: mergedBottomEdge,
          printables: mergedPrintables,
        };

        pieces.splice(topIdx, 2, mergedPiece);

        for (let i = topIdx + 1; i < pieces.length; i++) {
          pieces[i].offsetY = Math.max(0, pieces[i].offsetY - TEAR_GAP);
          pieces[i].rotation += (Math.random() - 0.5) * 0.35;
          animatePiece(pieces[i]);
        }

        animatePiece(mergedPiece);

        const maxOff = pieces.length > 0 ? pieces[pieces.length - 1].offsetY : 0;
        wrapper.style.paddingBottom = `${maxOff + 40}px`;
        return true;
      }

      // Animate a piece to its current state with a spring curve
      function animatePiece(p: TearPiece) {
        p.el.style.transition = 'transform 0.55s cubic-bezier(0.34, 1.56, 0.64, 1)';
        p.el.style.clipPath = clipFor(p);
        p.el.style.transform = transformFor(p);
      }

      function executeTear(swipeY: number): boolean {
        initTearSystem();

        const rr = receipt!.getBoundingClientRect();
        const rh = rr.height;

        // Find which piece the swipe Y falls within
        let target: TearPiece | null = null;
        let targetIdx = -1;
        let tearPct = 0;

        for (let i = 0; i < pieces.length; i++) {
          const p = pieces[i];
          const vTop = rr.top + (p.top / 100) * rh + p.offsetY;
          const vBot = rr.top + (p.bottom / 100) * rh + p.offsetY;
          const safeTop = vTop + CUT_EDGE_SAFETY;
          const safeBot = vBot - CUT_EDGE_SAFETY;
          // Accept clicks within piece OR within padding outside, then clamp
          if (swipeY >= safeTop - CUT_EDGE_PADDING && swipeY <= safeBot + CUT_EDGE_PADDING) {
            target = p;
            targetIdx = i;
            const clampedY = Math.max(safeTop, Math.min(safeBot, swipeY));
            tearPct = ((clampedY - rr.top - p.offsetY) / rh) * 100;
            break;
          }
        }

        if (!target) return false;

        sounds.tearSound();
        dismissCutHint();

        const origBottom = target.bottom;
        const origBottomEdge = target.bottomEdge;

        // Generate shared jagged edge for this tear (both pieces share it)
        const jaggedEdge = generateJaggedEdge();

        // Shrink target to top portion with new jagged bottom
        target.bottom = tearPct;
        target.bottomEdge = jaggedEdge;
        target.rotation += (Math.random() - 0.5) * 0.6;

        // Add grain texture to the top piece's newly torn bottom edge
        addEdgeGrain(target.el, tearPct, 'top');

        animatePiece(target);

        // Create new piece for bottom portion (jagged top, inherits old bottom edge)
        const wrapper = receipt!.parentElement!;
        const { el: newEl, printables: newPrintables } = makePieceEl(tearPct, origBottom, target.offsetY, target.rotation, jaggedEdge, origBottomEdge);
        wrapper.appendChild(newEl);

        // Transfer seam traces and washi strips that fall below the tear to the new piece
        for (const child of [...target.el.querySelectorAll(':scope > .tape-seam, :scope > .washi-strip')]) {
          const yPct = parseFloat(child.getAttribute('data-seam-y') || '0');
          if (yPct >= tearPct) {
            newEl.appendChild(child);
          }
        }

        const newPiece: TearPiece = {
          el: newEl,
          top: tearPct,
          bottom: origBottom,
          offsetY: target.offsetY,
          rotation: target.rotation,
          topEdge: jaggedEdge,
          bottomEdge: origBottomEdge,
          printables: newPrintables,
        };
        pieces.splice(targetIdx + 1, 0, newPiece);

        // Force reflow so the transition animates from the start position
        newEl.getBoundingClientRect();

        // Shift the new piece and everything below it down
        for (let i = targetIdx + 1; i < pieces.length; i++) {
          pieces[i].offsetY += TEAR_GAP;
          pieces[i].rotation += (Math.random() - 0.5) * 1.2;
          animatePiece(pieces[i]);
        }

        // Grow wrapper so page is scrollable to see all pieces
        const maxOff = pieces[pieces.length - 1].offsetY;
        wrapper.style.paddingBottom = (maxOff + 40) + 'px';

        return true;
      }

      // ---- Cursor proximity & visual state (desktop) ----

      let nearEdge = false;

      function getCursorProximity(mouseX: number, mouseY: number): { proximity: number; canCut: boolean } {
        if (!canCutDuringPrint()) return { proximity: 0, canCut: false };

        let distX = 0;
        let minDistY = Infinity;
        let insideTearable = false;

        if (!tearSystemReady || pieces.length === 0) {
          const rr = receipt!.getBoundingClientRect();

          // Horizontal distance to receipt
          if (mouseX < rr.left) distX = rr.left - mouseX;
          else if (mouseX > rr.right) distX = mouseX - rr.right;
          if (distX > PROXIMITY_RANGE) return { proximity: 0, canCut: false };

          const innerTop = rr.top + CUT_EDGE_SAFETY;
          const innerBottom = rr.bottom - CUT_EDGE_SAFETY;
          if (mouseY >= innerTop && mouseY <= innerBottom) {
            insideTearable = true;
            minDistY = 0;
          } else {
            if (mouseY < innerTop) minDistY = innerTop - mouseY;
            else minDistY = mouseY - innerBottom;
          }
        } else {
          // Use each piece's actual bounding rect (accounts for rotation/transforms)
          distX = Infinity;
          for (const p of pieces) {
            const pieceRect = p.el.getBoundingClientRect();

            let pdx = 0;
            if (mouseX < pieceRect.left) pdx = pieceRect.left - mouseX;
            else if (mouseX > pieceRect.right) pdx = mouseX - pieceRect.right;
            if (pdx > PROXIMITY_RANGE) continue;

            const innerTop = pieceRect.top + CUT_EDGE_SAFETY;
            const innerBot = pieceRect.bottom - CUT_EDGE_SAFETY;
            if (mouseY >= innerTop && mouseY <= innerBot) {
              insideTearable = true;
              minDistY = 0;
              distX = pdx;
              break;
            }
            let d = Infinity;
            if (mouseY < innerTop) d = innerTop - mouseY;
            else if (mouseY > innerBot) d = mouseY - innerBot;
            if (d < minDistY) {
              minDistY = d;
              distX = pdx;
            }
          }
          if (distX === Infinity) distX = PROXIMITY_RANGE + 1;
        }

        const totalDist = Math.sqrt(distX * distX + minDistY * minDistY);
        const canCut = (insideTearable || minDistY <= CUT_EDGE_PADDING) && distX <= CUT_EDGE_PADDING;
        const proximity = insideTearable ? 1 : Math.max(0, 1 - totalDist / PROXIMITY_RANGE);

        return { proximity, canCut };
      }

      function updateCursorVisual(proximity: number, canCut: boolean, isTearing: boolean) {
        if (!cursorDot) return;

        let size: number;
        if (isTearing) {
          size = DOT_SIZE_MIN;
        } else if (canCut) {
          size = DOT_SIZE_MAX;
        } else {
          size = DOT_SIZE_MIN + (DOT_SIZE_MAX - DOT_SIZE_MIN) * proximity;
        }

        const splitOffset = (canCut && !isTearing) ? SPLIT_GAP : 0;

        cursorDot.style.setProperty('--dot-size', size + 'px');
        cursorDot.style.setProperty('--split-offset', (-splitOffset) + 'px');
        cursorDot.style.setProperty('--split-offset-inv', splitOffset + 'px');
      }

      function checkEdgeProximity(mouseX: number, mouseY: number) {
        if (washiMode) {
          nearEdge = false;
          updateCursorVisual(0, false, false);
          return;
        }
        if (!canCutDuringPrint()) {
          nearEdge = false;
          updateCursorVisual(0, false, false);
          return;
        }
        const { proximity, canCut } = getCursorProximity(mouseX, mouseY);
        nearEdge = canCut;
        updateCursorVisual(proximity, canCut, false);
      }

      function finishWashiStroke(stroke: TapeStroke) {
        if (!washiMode) return;
        if (Math.hypot(stroke.endX - stroke.startX, stroke.endY - stroke.startY) < MIN_WASHI_STROKE) return;
        let seamIdx = findSeamIndexForStroke(stroke);
        let merged = seamIdx >= 0 ? mergePiecesAt(seamIdx, stroke) : false;
        if (!merged) {
          seamIdx = findNearestSeamByMidpoint(stroke);
          if (seamIdx >= 0) {
            merged = mergePiecesAt(seamIdx, stroke);
          }
        }
        if (!merged) {
          addFreeWashiStrip(stroke);
        }
        sounds.tearSound();
      }

      function startWashiStroke(clientX: number, clientY: number) {
        washiDrawing = true;
        washiStartX = clientX;
        washiStartY = clientY;
        washiCurrentX = clientX;
        washiCurrentY = clientY;
        washiPreviewClip = createWashiClipPath();
        washiPreview.style.setProperty('--washi-alpha', (0.82 + Math.random() * 0.10).toFixed(2));
        updateWashiPreview();
      }

      function updateWashiStroke(clientX: number, clientY: number) {
        if (!washiDrawing) return;
        washiCurrentX = clientX;
        washiCurrentY = clientY;
        updateWashiPreview();
      }

      function endWashiStroke() {
        if (!washiDrawing) return;
        const stroke: TapeStroke = {
          startX: washiStartX,
          startY: washiStartY,
          endX: washiCurrentX,
          endY: washiCurrentY,
        };
        washiDrawing = false;
        hideWashiPreview();
        finishWashiStroke(stroke);
      }

      if (usePointerWashi) {
        document.addEventListener('pointerdown', (e: PointerEvent) => {
          if (!washiMode) return;
          if (e.isPrimary === false) return;
          if (e.pointerType === 'mouse' && e.button !== 0) return;
          if ((e.target as HTMLElement).closest('button')) return;
          if ((e.target as HTMLElement).closest('a')) return;
          if (!washiDrawing && activeWashiPointerId !== null) activeWashiPointerId = null;
          if (washiDrawing) return;
          activeWashiPointerId = e.pointerId;
          startWashiStroke(e.clientX, e.clientY);
          e.preventDefault();
        });

        document.addEventListener('pointermove', (e: PointerEvent) => {
          if (!washiMode || activeWashiPointerId !== e.pointerId) return;
          updateWashiStroke(e.clientX, e.clientY);
          e.preventDefault();
        });

        const finishPointerWashi = (e: PointerEvent) => {
          if (activeWashiPointerId !== e.pointerId) return;
          updateWashiStroke(e.clientX, e.clientY);
          activeWashiPointerId = null;
          endWashiStroke();
          e.preventDefault();
        };
        document.addEventListener('pointerup', finishPointerWashi);
        document.addEventListener('pointercancel', finishPointerWashi);
      }

      // ---- Desktop click-to-tear ----

      if (desktopFinePointer) {
        let desktopTearing = false;
        let desktopTearStartX = 0;
        let desktopTearStartY = 0;
        let desktopTearDecided = false;

        document.addEventListener('mousemove', (e: MouseEvent) => {
          if (washiDrawing && (!usePointerWashi || activeWashiPointerId === null)) {
            washiCurrentX = e.clientX;
            washiCurrentY = e.clientY;
            updateWashiPreview();
            return;
          }
          if (!desktopTearing) {
            checkEdgeProximity(e.clientX, e.clientY);
          }
        });

        document.addEventListener('mousedown', (e: MouseEvent) => {
          if ((e.target as HTMLElement).closest('button')) return;
          if ((e.target as HTMLElement).closest('a')) return;

          if (washiMode) {
            if (usePointerWashi && activeWashiPointerId !== null && washiDrawing) return;
            if (washiDrawing) return;
            startWashiStroke(e.clientX, e.clientY);
            return;
          }

          if (!canCutDuringPrint()) return;

          if (!nearEdge) {
            if (!tearSystemReady || pieces.length === 0) {
              const rr = receipt!.getBoundingClientRect();
              if (e.clientX < rr.left - CUT_EDGE_PADDING || e.clientX > rr.right + CUT_EDGE_PADDING) return;
              if (e.clientY < rr.top + CUT_EDGE_SAFETY || e.clientY > rr.bottom - CUT_EDGE_SAFETY) return;
            } else {
              return;
            }
          }

          desktopTearing = true;
          desktopTearStartX = e.clientX;
          desktopTearStartY = e.clientY;
          desktopTearDecided = false;

          updateCursorVisual(1, true, true);
        });

        document.addEventListener('mousemove', (e: MouseEvent) => {
          if (!desktopTearing) return;

          updateCursorVisual(1, true, true);

          const dx = Math.abs(e.clientX - desktopTearStartX);
          const dy = Math.abs(e.clientY - desktopTearStartY);

          if (!desktopTearDecided && (dx > 8 || dy > 8)) {
            desktopTearDecided = true;
            const isHorizontal = dx > dy * 1.2;
            if (!isHorizontal) {
              endDesktopTear();
              return;
            }
            pageCutLine.style.top = `${desktopTearStartY}px`;
            pageCutLine.style.display = 'block';
            pageCutLine.style.width = '0';
          }

          if (!desktopTearDecided) return;

          const progress = Math.min(1, dx / (30));
          pageCutLine.style.width = `${progress * 100}%`;

          if (progress >= 1) {
            executeTear(desktopTearStartY);
            endDesktopTear();
          }
        });

        document.addEventListener('mouseup', () => {
          if (desktopTearing) endDesktopTear();
          if (usePointerWashi && activeWashiPointerId !== null && washiDrawing) return;
          if (!washiDrawing) return;
          endWashiStroke();
        });

        function endDesktopTear() {
          desktopTearing = false;
          desktopTearDecided = false;
          pageCutLine.style.width = '0';
          pageCutLine.style.display = 'none';
          // Keep cursor small briefly after release
          updateCursorVisual(0, false, false);
          setTimeout(() => {
            if (!desktopTearing && !washiMode) checkEdgeProximity(dotTargetX, dotTargetY);
          }, 100);
        }
      }

      document.addEventListener('keydown', (e: KeyboardEvent) => {
        if (e.repeat) return;
        const key = e.key.toLowerCase();
        const active = document.activeElement as HTMLElement | null;
        if (
          active &&
          (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)
        ) {
          return;
        }
        if (key === 'w') {
          washiMode = !washiMode;
          if (!washiMode && washiDrawing) {
            activeWashiPointerId = null;
            washiDrawing = false;
            hideWashiPreview();
          }
          syncWashiToggle();
          flashButton(tapeToggle);
          e.preventDefault();
        } else if (key === 'c' && washiMode) {
          clearAllTape();
          flashButton(clearTapeBtn);
          e.preventDefault();
        } else if (key === 's') {
          toggleSound();
          flashButton(soundToggle);
          e.preventDefault();
        }
      });

      // ---- Touch gesture detection (swipe anywhere, mobile) ----

      let tearStartX = 0;
      let tearStartY = 0;
      let isTearing = false;
      let tearDecided = false;
      let tearIsHorizontal = false;

      function startTear(cx: number, cy: number) {
        if (washiMode) return;
        if (!canCutDuringPrint()) return;
        tearStartX = cx;
        tearStartY = cy;
        isTearing = true;
        tearDecided = false;
        tearIsHorizontal = false;
      }

      function moveTear(cx: number, cy: number) {
        if (!isTearing) return;
        const dx = Math.abs(cx - tearStartX);
        const dy = Math.abs(cy - tearStartY);

        if (!tearDecided && (dx > 12 || dy > 12)) {
          tearDecided = true;
          tearIsHorizontal = dx > dy * 1.8;
          if (tearIsHorizontal) {
            pageCutLine.style.top = `${tearStartY}px`;
            pageCutLine.style.display = 'block';
            pageCutLine.style.width = '0';
          }
        }

        if (!tearDecided || !tearIsHorizontal) return;

        const progress = Math.min(1, dx / (30));
        pageCutLine.style.width = `${progress * 100}%`;

        if (progress >= 1) {
          executeTear(tearStartY);
          endTear();
        }
      }

      function endTear() {
        pageCutLine.style.width = '0';
        pageCutLine.style.display = 'none';
        isTearing = false;
        tearDecided = false;
        tearIsHorizontal = false;
      }

      // Touch (swipe gesture stays the same for mobile)
      document.addEventListener('touchstart', (e: TouchEvent) => {
        if ((e.target as HTMLElement).closest('button')) return;
        if ((e.target as HTMLElement).closest('a')) return;
        if (washiMode) {
          if (usePointerWashi && activeWashiPointerId !== null && washiDrawing) return;
          if (e.touches.length === 0) return;
          if (washiDrawing) return;
          startWashiStroke(e.touches[0].clientX, e.touches[0].clientY);
          return;
        }
        startTear(e.touches[0].clientX, e.touches[0].clientY);
      }, { passive: true });
      document.addEventListener('touchmove', (e: TouchEvent) => {
        if (washiMode && washiDrawing && (usePointerWashi ? activeWashiPointerId === null : true) && e.touches.length > 0) {
          updateWashiStroke(e.touches[0].clientX, e.touches[0].clientY);
          e.preventDefault();
          return;
        }
        if (isTearing && e.touches.length > 0) {
          moveTear(e.touches[0].clientX, e.touches[0].clientY);
          // Prevent browser back/forward navigation gesture during horizontal tear
          if (tearIsHorizontal) e.preventDefault();
        }
      }, { passive: false });
      document.addEventListener('touchend', () => {
        if (washiMode && washiDrawing && (usePointerWashi ? activeWashiPointerId === null : true)) {
          endWashiStroke();
          return;
        }
        if (isTearing) endTear();
      });
    }

    // ========================================
    // 7. KICK OFF THE PRINTING
    // ========================================
    startPrinting();

  });
</script>
