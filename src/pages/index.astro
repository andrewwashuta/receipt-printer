---
import ReceiptLayout from "../layouts/ReceiptLayout.astro";
import Avatar from '../assets/index/images/andrewwashuta.png';
---

<ReceiptLayout
  description="Product designer in Albuquerque, NM. Leading design systems at Kroger, building at Universal.xyz. Designing where human intent meets machine capability."
>
  <!-- Toolbar -->
  <div class="toolbar" id="toolbar">
    <button class="toolbar-btn active" id="soundToggle" aria-label="Toggle sounds" title="Toggle sounds">
      <span class="toolbar-label" id="soundLabel">Sound &bull; On</span>
      <span class="toolbar-icon" id="soundIcon">&#x1F50A;</span>
      <span class="toolbar-key">S</span>
    </button>
    <button class="toolbar-btn" id="tapeToggle" aria-label="Toggle washi tape" title="Toggle washi tape">
      <span class="toolbar-label" id="tapeLabel">Washi &bull; Off</span>
      <span class="toolbar-icon" id="tapeIcon">&#x1F517;</span>
      <span class="toolbar-key">W</span>
    </button>
    <button class="toolbar-btn toolbar-btn--washi-only" id="clearTape" aria-label="Clear tape" title="Clear tape">
      <span class="toolbar-label">Clear Tape</span>
      <span class="toolbar-icon">&#x1F5D1;</span>
      <span class="toolbar-key">C</span>
    </button>
    <button class="toolbar-btn" id="cutToggle" aria-label="Toggle draw-to-cut mode" title="Toggle draw-to-cut mode">
      <span class="toolbar-label" id="cutLabel">Draw to Cut &bull; Off</span>
      <span class="toolbar-icon">&#x270F;</span>
      <span class="toolbar-key">X</span>
    </button>
    <button class="toolbar-btn" id="handToggle" aria-label="Toggle drag mode" title="Toggle drag mode">
      <span class="toolbar-label" id="handLabel">Drag &bull; Off</span>
      <span class="toolbar-icon">&#x261A;</span>
      <span class="toolbar-key">H</span>
    </button>
    <button class="toolbar-btn" id="resetBtn" aria-label="Reset receipt" title="Reset receipt">
      <span class="toolbar-label">Reset</span>
      <span class="toolbar-icon">&#128257;</span>
      <span class="toolbar-key">R</span>
    </button>
  </div>

  <!-- Theme cycle button -->
  <button class="theme-btn" id="themeToggle" aria-label="Cycle color theme" title="Cycle color theme">
    <span class="theme-btn-dot"></span>
    <span class="toolbar-label" id="themeLabel">Parchment</span>
  </button>

  <!-- Mobile mode hint (shimmer text above toolbar) -->
  <div class="mode-hint" id="modeHint" aria-live="polite"></div>

  <!-- Inverse cursor dot (desktop only) -->
  <div class="cursor-dot" id="cursorDot"></div>

  <div class="receipt-wrapper">
    <div class="receipt" id="receipt">

      <!-- ============================================ -->
      <!-- TOP EDGE (torn from previous receipt)        -->
      <!-- ============================================ -->
      <div class="receipt-top-tear" data-print></div>

      <!-- ============================================ -->
      <!-- STORE HEADER                                  -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line center divider" data-print>================================</pre>
        <pre class="receipt-line center big" data-print>    ANDREW WASHUTA</pre>
        <pre class="receipt-line center" data-print>    PRODUCT DESIGNER</pre>
        <pre class="receipt-line center divider" data-print>================================</pre>
      </div>

      <!-- ============================================ -->
      <!-- TRANSACTION META (dynamic via JS)             -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line" data-print>DATE: <span id="receiptDate">loading...</span></pre>
        <pre class="receipt-line" data-print>ORDER #: <span id="receiptOrder">-----</span></pre>
        <pre class="receipt-line" data-print>CASHIER: THE INTERNET</pre>
        <pre class="receipt-line" data-print>--------------------------------</pre>
      </div>

      <!-- ============================================ -->
      <!-- ABOUT                                         -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line bold" data-print>ABOUT</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line wrap" data-print>Hey there, I'm Andrew — husband, dad, trail runner, Parks lover, designer. Based in New Mexico.</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line wrap" data-print>Currently shipping ad platforms and leading design systems at Kroger by day, while building a wrapped asset protocol by night at Universal.xyz</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line wrap" data-print>I design for and with AI — shaping interfaces where human intent meets machine capability, and building tools that make both sides better at what they do.</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line row" data-print><span>LOCATION:</span><span>Albuquerque, NM</span></pre>
        <pre class="receipt-line row" data-print><span>ELEVATION:</span><span>5,312 ft</span></pre>
        <pre class="receipt-line" data-print>--------------------------------</pre>
      </div>

      <!-- ============================================ -->
      <!-- SKILLS                                        -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line bold" data-print>SKILLS</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line row" data-print><span>  1x  Product Design</span><span>*****</span></pre>
        <pre class="receipt-line row" data-print><span>  1x  Design Systems</span><span>*****</span></pre>
        <pre class="receipt-line row" data-print><span>  1x  Visual Design</span><span>*****</span></pre>
        <pre class="receipt-line row" data-print><span>  1x  Brand Design</span><span>****</span></pre>
        <pre class="receipt-line row" data-print><span>  1x  Prototyping</span><span>***</span></pre>
        <pre class="receipt-line row" data-print><span>  1x  Front-end Dev</span><span>***</span></pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line row bold" data-print><span>  SUBTOTAL (6 items)</span><span>PRICELESS</span></pre>
        <pre class="receipt-line" data-print>--------------------------------</pre>
      </div>

      <!-- ============================================ -->
      <!-- PORTRAIT (Dithered)                           -->
      <!-- ============================================ -->
      <div class="receipt-section portrait-section" data-print-section>
        <div class="portrait-container" data-print data-src={Avatar.src}>
          <canvas id="portraitCanvas"></canvas>
          <noscript>
            <img src={Avatar.src} alt="Andrew Washuta" width="280" />
          </noscript>
        </div>
        <pre class="receipt-line center faded" data-print>[ THERMAL PORTRAIT ]</pre>
        <pre class="receipt-line" data-print>--------------------------------</pre>
      </div>

      <!-- ============================================ -->
      <!-- EXPERIENCE                                    -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line bold" data-print>EXPERIENCE</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line bold" data-print>  84.51°, A Kroger Company</pre>
        <pre class="receipt-line dotleader" data-print><span>  Lead Product Designer</span><span>2017-NOW</span></pre>
        <pre class="receipt-line" data-print>  Ad Platforms, Design Systems,</pre>
        <pre class="receipt-line" data-print>  Insights</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line bold" data-print>  Universal.xyz</pre>
        <pre class="receipt-line dotleader" data-print><span>  Design Lead</span><span>2022-NOW</span></pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line bold" data-print>  Clubessential</pre>
        <pre class="receipt-line dotleader" data-print><span>  Web Designer</span><span>2016-2017</span></pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line bold" data-print>  UnitedHealthcare</pre>
        <pre class="receipt-line dotleader" data-print><span>  Brand Designer</span><span>2014-2016</span></pre>
        <pre class="receipt-line" data-print>--------------------------------</pre>
      </div>

      <!-- ============================================ -->
      <!-- NOW                                           -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line bold" data-print>CURRENTLY</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line wrap" data-print>  * Cherishing every moment with my wife, Seneca, and our kiddos, Thor and Raya</pre>
        <pre class="receipt-line wrap" data-print>  * Living as a "cyborg" healing a broken hip socket</pre>
        <pre class="receipt-line wrap" data-print>  * Dreaming up recipes with unique ingredients</pre>
        <pre class="receipt-line wrap" data-print>  * Collecting vintage National Park brochures</pre>
        <pre class="receipt-line wrap" data-print>  * Falling back in love with code</pre>
        <pre class="receipt-line" data-print>--------------------------------</pre>
      </div>

      <!-- ============================================ -->
      <!-- EDUCATION                                     -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line bold" data-print>EDUCATION</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line bold" data-print>  Clarkson University</pre>
        <pre class="receipt-line" data-print>  B.S. Digital Arts & Sciences</pre>
        <pre class="receipt-line" data-print>  Minor: Business Administration</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line center divider" data-print>================================</pre>
      </div>

      <!-- ============================================ -->
      <!-- SUBTOTAL / CONTACT                            -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line bold" data-print>CONTACT</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line row" data-print><span>WEB</span><span><a href="https://andrew.cv">andrew.cv</a></span></pre>
        <pre class="receipt-line row" data-print><span>EMAIL</span><span><a href="mailto:hello@andrew.cv">hello@andrew.cv</a></span></pre>
        <pre class="receipt-line row" data-print><span>LINKEDIN</span><span><a href="https://linkedin.com/in/awashuta" target="_blank">/in/awashuta</a></span></pre>
        <pre class="receipt-line row" data-print><span>X</span><span><a href="https://x.com/awashuta" target="_blank">@awashuta</a></span></pre>
        <pre class="receipt-line row" data-print><span>INSTAGRAM</span><span><a href="https://instagram.com/andrewwashuta" target="_blank">@andrewwashuta</a></span></pre>
        <pre class="receipt-line row" data-print><span>REFRAKT</span><span><a href="https://refrakt.app/andrew" target="_blank">refrakt.app/andrew</a></span></pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line center divider" data-print>================================</pre>
      </div>

      <!-- ============================================ -->
      <!-- BARCODE                                       -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <div class="barcode-container" data-print>
          <canvas id="barcodeCanvas" width="200" height="50"></canvas>
        </div>
        <pre class="receipt-line center faded" data-print id="barcodeNumber">0000 0000 0000</pre>
      </div>

      <!-- ============================================ -->
      <!-- VISITOR COUNTER                               -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line row" data-print><span>GUESTS SERVED:</span><span id="visitorCount">00000</span></pre>
        <pre class="receipt-line" data-print>--------------------------------</pre>
      </div>

      <!-- ============================================ -->
      <!-- FOOTER / THANK YOU                            -->
      <!-- ============================================ -->
      <div class="receipt-section" data-print-section>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line center bold" data-print>THANK YOU FOR VISITING!</pre>
        <pre class="receipt-line center faded" data-print>Have a great day.</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line center faded small" data-print>Items sold final.</pre>
        <pre class="receipt-line center faded small" data-print>No returns on experience.</pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line center faded" data-print>- - - - - - - - - - - - - - -</pre>
        <pre class="receipt-line center faded small" data-print>Typeset in <a href="https://usgraphics.com/products/berkeley-mono" target="_blank">Berkeley Mono</a></pre>
        <pre class="receipt-line spacer" data-print> </pre>
        <pre class="receipt-line center faded" data-print>&#x2702; TEAR ANYWHERE &#x2014; 2026 &#x2702;</pre>
      </div>

      <!-- Bottom torn edge -->
      <div class="receipt-bottom-tear" data-print></div>

    </div>
  </div>
</ReceiptLayout>

<style>
  /* ============================================ */
  /* RECEIPT WRAPPER & CONTAINER                   */
  /* ============================================ */

  .receipt-wrapper {
    display: flex;
    justify-content: center;
    position: relative;
    width: 100%;
    max-width: 100%;
  }

  .receipt {
    width: 380px;
    max-width: 100%;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    background: var(--color-paper);
    background-image:
      linear-gradient(
        180deg,
        var(--color-paper-aging-top) 0%,
        transparent 3%,
        transparent 50%,
        var(--color-paper-aging-bottom) 80%,
        rgba(0,0,0,0.04) 100%
      );
    padding: 32px 24px;
    position: relative;
    transform: rotate(-1.2deg);
    box-shadow:
      0 1px 4px rgba(0,0,0,0.2),
      0 4px 16px rgba(0,0,0,0.15),
      0 12px 48px rgba(0,0,0,0.1);
    overflow: hidden;
    filter: var(--receipt-filter);
  }

  .receipt * {
    user-select: none;
    -webkit-user-select: none;
    -webkit-user-drag: none;
  }

  /* Paper texture overlay - subtle horizontal feed lines */
  .receipt::before {
    content: "";
    position: absolute;
    inset: 0;
    background-image:
      repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0,0,0,0.012) 2px,
        rgba(0,0,0,0.012) 3px
      );
    pointer-events: none;
    z-index: 2;
  }

  /* Noise texture for paper grain */
  .receipt::after {
    content: "";
    position: absolute;
    inset: 0;
    opacity: 0.45;
    pointer-events: none;
    z-index: 1;
    mix-blend-mode: multiply;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.2' numOctaves='5' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.12'/%3E%3C/svg%3E");
    background-size: 200px 200px;
  }

  /* Top torn edge - from previous receipt */
  .receipt-top-tear {
    position: absolute;
    top: -6px;
    left: 0;
    right: 0;
    height: 8px;
    background: var(--color-paper);
    clip-path: polygon(
      0% 100%, 2% 40%, 4% 100%, 6% 50%, 8% 100%, 10% 30%, 
      12% 100%, 14% 60%, 16% 100%, 18% 40%, 20% 100%, 22% 50%,
      24% 100%, 26% 30%, 28% 100%, 30% 60%, 32% 100%, 34% 40%,
      36% 100%, 38% 50%, 40% 100%, 42% 30%, 44% 100%, 46% 60%,
      48% 100%, 50% 40%, 52% 100%, 54% 50%, 56% 100%, 58% 30%,
      60% 100%, 62% 60%, 64% 100%, 66% 40%, 68% 100%, 70% 50%,
      72% 100%, 74% 30%, 76% 100%, 78% 60%, 80% 100%, 82% 40%,
      84% 100%, 86% 50%, 88% 100%, 90% 30%, 92% 100%, 94% 60%,
      96% 100%, 98% 40%, 100% 100%
    );
    z-index: 3;
  }

  /* Bottom torn edge */
  .receipt-bottom-tear {
    position: absolute;
    bottom: -8px;
    left: 0;
    right: 0;
    height: 10px;
    background: var(--color-paper);
    clip-path: polygon(
      0% 0%, 3% 70%, 5% 0%, 8% 60%, 11% 0%, 13% 80%, 
      16% 0%, 19% 50%, 21% 0%, 24% 70%, 27% 0%, 29% 60%,
      32% 0%, 35% 80%, 37% 0%, 40% 50%, 43% 0%, 45% 70%,
      48% 0%, 51% 60%, 53% 0%, 56% 80%, 59% 0%, 61% 50%,
      64% 0%, 67% 70%, 69% 0%, 72% 60%, 75% 0%, 77% 80%,
      80% 0%, 83% 50%, 85% 0%, 88% 70%, 91% 0%, 93% 60%,
      96% 0%, 98% 80%, 100% 0%
    );
    z-index: 3;
  }

  /* ============================================ */
  /* RECEIPT LINES                                 */
  /* ============================================ */

  .receipt-section {
    position: relative;
    z-index: 3;
  }

  .receipt-line {
    font-family: var(--font-receipt);
    font-size: 13px;
    line-height: 1.5;
    letter-spacing: 0.04em;
    color: var(--color-ink);
    white-space: pre;
    margin: 0;
    padding: 0;
    border: none;
    background: none;
    display: block;
    opacity: 0;
    transform: translateY(1px);
    position: relative;
    overflow: hidden;
  }

  .receipt-line.printed {
    opacity: 1;
    transform: translateY(0);
  }

  .receipt-line.wrap {
    white-space: pre-wrap;
    word-wrap: break-word;
    max-width: 100%;
    line-height: 1.65;
  }

  .receipt-line.center {
    text-align: center;
  }

  .receipt-line.big {
    font-weight: 700;
    letter-spacing: 0.1em;
    text-transform: uppercase;
  }

  .receipt-line.bold {
    color: var(--color-ink-bold);
    font-weight: 700;
    letter-spacing: 0.06em;
    text-transform: uppercase;
  }

  .receipt-line.divider {
    font-weight: 400;
    color: var(--color-ink-divider);
  }

  .receipt-line.faded {
    color: var(--color-ink-faded);
  }

  .receipt-line.small {
    font-size: 11px;
  }

  .receipt-line.spacer {
    line-height: 0.8;
  }

  /* Row layout for aligned columns */
  .receipt-line.row {
    display: flex;
    justify-content: space-between;
    gap: 8px;
  }

  .receipt-line.row.printed {
    display: flex;
  }

  .receipt-line.row span {
    white-space: nowrap;
  }

  /* Dot-leader rows (experience items) */
  .receipt-line.dotleader {
    display: flex;
    gap: 0;
    overflow: hidden;
  }

  .receipt-line.dotleader.printed {
    display: flex;
  }

  .receipt-line.dotleader span:first-child {
    white-space: nowrap;
    flex-shrink: 0;
    order: 1;
  }

  .receipt-line.dotleader span:last-child {
    white-space: nowrap;
    flex-shrink: 0;
    order: 3;
  }

  /* Dotted line fills the gap between spans */
  .receipt-line.dotleader::before {
    content: "";
    order: 2;
    flex: 1;
    border-bottom: 1px dotted var(--color-ink-dotleader);
    margin: 0 4px;
    margin-bottom: 5px;
    min-width: 8px;
  }

  /* Subtle print artifact - random slight offset on some lines */
  .receipt-line.artifact {
    transform: translateX(0.5px);
  }

  /* Links in receipt */
  .receipt-line :global(a) {
    color: var(--color-ink);
    text-decoration: underline;
    text-decoration-style: dashed;
    text-underline-offset: 3px;
    text-decoration-thickness: 1px;
    text-decoration-color: var(--color-link-underline);
    transition: color 0.15s, text-decoration-color 0.15s;
    pointer-events: auto;
    cursor: pointer;
  }

  .receipt-line :global(a:hover) {
    color: var(--color-link-hover);
    text-decoration-color: var(--color-link-hover);
  }

  /* Barcode */
  .barcode-container {
    display: flex;
    justify-content: center;
    margin: 8px 0 4px;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .barcode-container.printed {
    opacity: 1;
  }

  #barcodeCanvas {
    display: block;
    width: 200px;
    height: 50px;
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
  }

  /* ============================================ */
  /* PORTRAIT                                      */
  /* ============================================ */

  .portrait-container {
    width: 100%;
    display: flex;
    justify-content: center;
    margin: 8px 0;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .portrait-container.printed {
    opacity: 1;
  }

  #portraitCanvas,
  .portrait-img {
    width: 100%;
    max-width: 280px;
    height: auto;
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
  }

  /* ============================================ */
  /* PRINT CURSOR EFFECT                           */
  /* ============================================ */

  .receipt-line.printing {
    transition: opacity 0.05s ease, transform 0.05s ease;
  }

  .receipt-line.printing:not(.row):not(.dotleader):not(.spacer)::after {
    content: "█";
    animation: blink 0.4s step-end infinite;
    color: var(--color-ink);
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }

  /* ============================================ */
  /* TOOLBAR                                        */
  /* ============================================ */

  .toolbar {
    position: fixed;
    top: 54px;
    right: 20px;
    z-index: 10100;
    display: flex;
    flex-direction: column;
    background: var(--color-toolbar-bg);
    border: 1px solid var(--color-toolbar-border);
    border-radius: 12px;
    padding: 4px;
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
  }

  .toolbar-btn {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 36px;
    background: transparent;
    border: none;
    border-radius: 8px;
    color: var(--color-btn-default);
    cursor: pointer;
    transition: color 0.2s, background 0.2s;
    padding: 0;
    margin: 0;
    outline: none;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
  }

  .toolbar-btn + .toolbar-btn {
    margin-top: 2px;
  }

  .toolbar-btn.active {
    color: var(--color-btn-active-text);
    background: var(--color-btn-active-bg);
  }

  .toolbar-btn:hover {
    color: var(--color-btn-hover);
    background: var(--color-btn-active-bg);
  }

  .toolbar-icon {
    font-family: var(--font-thermo), sans-serif;
    font-weight: 400;
    font-size: 20px;
    line-height: 1;
  }

  .toolbar-key {
    position: absolute;
    bottom: 2px;
    right: 3px;
    font-family: var(--font-receipt);
    font-size: 9px;
    opacity: 0.45;
    line-height: 1;
  }

  .toolbar-label {
    position: absolute;
    right: calc(100% + 13px);
    top: 50%;
    transform: translateY(-50%) translateX(4px);
    white-space: nowrap;
    font-family: var(--font-receipt);
    font-size: 9px;
    letter-spacing: 1px;
    background: var(--color-label-bg);
    padding: 3px 8px;
    border: 1px solid var(--color-toolbar-border);
    color: var(--color-label-text);
    opacity: 0;
    pointer-events: none;
    filter: blur(3px);
    transition: opacity 0.2s ease, transform 0.2s ease, filter 0.2s ease;
  }

  .toolbar-btn:hover .toolbar-label {
    opacity: 1;
    transform: translateY(-50%) translateX(0);
    filter: blur(0);
  }

  .toolbar-btn--washi-only {
    max-height: 0;
    margin-top: 0;
    overflow: hidden;
    opacity: 0;
    transition: max-height 0.25s ease, opacity 0.2s ease, margin-top 0.25s ease;
  }

  :global(body.washi-mode) .toolbar-btn--washi-only {
    max-height: 36px;
    margin-top: 2px;
    opacity: 1;
  }

  .toolbar-btn--pressed {
    color: var(--color-btn-hover);
  }

  /* ============================================ */
  /* THEME BUTTON                                  */
  /* ============================================ */

  .theme-btn {
    position: fixed;
    top: 20px;
    right: 28px;
    z-index: 10100;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background: var(--color-toolbar-bg);
    border: 1px solid var(--color-toolbar-border);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    cursor: pointer;
    padding: 0;
    outline: none;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
    transition: transform 0.2s ease;
  }

  .theme-btn:hover {
    transform: scale(1.1);
  }

  .theme-btn .toolbar-label {
    right: calc(100% + 10px);
    top: 50%;
    transform: translateY(-50%) translateX(4px);
  }

  .theme-btn:hover .toolbar-label {
    opacity: 1;
    transform: translateY(-50%) translateX(0);
    filter: blur(0);
  }

  .theme-btn-dot {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: var(--color-paper);
    transition: background 0.3s ease;
  }

  @media (max-width: 600px) {
    .toolbar {
      top: auto;
      bottom: calc(20px + env(safe-area-inset-bottom) + var(--vv-bottom-offset, 0px));
      right: auto;
      left: 50%;
      transform: translateX(-50%);
      flex-direction: row;
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
      background: var(--color-toolbar-bg);
      border: 1px solid var(--color-toolbar-border);
    }

    .toolbar-btn + .toolbar-btn {
      margin-top: 0;
      margin-left: 2px;
    }

    .toolbar-btn.active {
      color: var(--color-btn-active-text);
      background: var(--color-btn-active-bg);
    }

    .toolbar-label,
    .toolbar-key {
      display: none;
    }

    .toolbar-btn--washi-only {
      max-height: 36px;
      max-width: 0;
      margin-top: 0;
      margin-left: 0;
      opacity: 0;
      transition: max-width 0.25s ease, opacity 0.2s ease, margin-left 0.25s ease;
    }

    :global(body.washi-mode) .toolbar-btn--washi-only {
      max-width: 36px;
      margin-left: 2px;
      margin-top: 0;
      opacity: 1;
    }

    .theme-btn {
      top: auto;
      right: auto;
      left: calc(50% - 158px);
      bottom: calc(28px + env(safe-area-inset-bottom) + var(--vv-bottom-offset, 0px));
      transform: none;
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
      transition: transform 0.2s ease, left 0.25s ease;
    }

    :global(body.washi-mode) .theme-btn {
      left: calc(50% - 177px);
    }

    .theme-btn:hover {
      transform: scale(1.1);
    }
  }

  /* Mobile unified label (replaces per-button toolbar labels) */
  .mode-hint {
    display: none;
  }

  @media (max-width: 600px) {
    .mode-hint {
      display: block;
      position: fixed;
      left: 50%;
      bottom: calc(72px + env(safe-area-inset-bottom) + var(--vv-bottom-offset, 0px));
      transform: translateX(-50%);
      z-index: 10100;
      font-family: var(--font-receipt);
      font-size: 9px;
      letter-spacing: 1px;
      white-space: nowrap;
      pointer-events: none;
      padding: 3px 8px;
      background: var(--color-label-bg);
      border: 1px solid var(--color-toolbar-border);
      color: var(--color-label-text);
      opacity: 0;
      transition: opacity 0.4s ease;
    }

    .mode-hint.visible {
      opacity: 1;
    }

    .mode-hint.mode-hint--theme {
      left: calc(50% - 143px);
    }

    :global(body.washi-mode) .mode-hint.mode-hint--theme {
      left: calc(50% - 162px);
    }

  }

  :global(.washi-preview),
  :global(.washi-strip) {
    border: none;
    border-radius: 3px;
    background-color: rgba(236, 236, 236, 0.72);
    background:
      linear-gradient(
        180deg,
        rgba(255, 255, 255, calc(var(--washi-alpha, 0.72) * 0.35)) 0%,
        rgba(230, 230, 230, calc(var(--washi-alpha, 0.72) * 0.25)) 100%
      ),
      repeating-conic-gradient(
        from 0deg,
        rgba(10, 10, 10, 0.6) 0% 25%,
        rgba(255, 255, 255, 0.7) 25% 50%
      );
    background-size:
      auto,
      12px 12px;
    background-position:
      0 0,
      0 0;
    box-shadow:
      0 1px 0 rgba(255, 255, 255, 0.44) inset,
      0 2px 2px rgba(12, 12, 12, 0.34),
      0 6px 14px rgba(10, 10, 10, 0.34);
    overflow: hidden;
    pointer-events: none;
    transform-origin: center;
    opacity: 0.88;
    filter: saturate(1.2) contrast(1.08);
  }

  :global(.washi-preview)::before,
  :global(.washi-strip)::before {
    content: "";
    position: absolute;
    inset: 0;
    background:
      repeating-linear-gradient(
        45deg,
        rgba(8, 8, 8, 0.3) 0,
        rgba(8, 8, 8, 0.3) 5px,
        rgba(255, 255, 255, 0) 6px,
        rgba(255, 255, 255, 0) 12px
      ),
      repeating-linear-gradient(
        -45deg,
        rgba(255, 255, 255, 0.34) 0,
        rgba(255, 255, 255, 0.34) 5px,
        rgba(255, 255, 255, 0) 6px,
        rgba(255, 255, 255, 0) 12px
      );
    opacity: 0.5;
  }

  :global(.washi-preview)::after,
  :global(.washi-strip)::after {
    content: "";
    position: absolute;
    inset: 0;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.6' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.24'/%3E%3C/svg%3E");
    background-size: 120px 120px;
    opacity: 0.22;
    mix-blend-mode: multiply;
  }

  :global(.washi-preview) {
    position: fixed;
    left: 0;
    top: 0;
    width: 0;
    height: 0;
    z-index: 360;
    display: none;
    min-height: 20px;
    min-width: 22px;
  }

  :global(.washi-overlay) {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10050;
  }

  :global(.washi-strip) {
    position: absolute;
    left: 0;
    top: 0;
    z-index: 10051;
    min-height: 20px;
    min-width: 22px;
  }

  :global(.tape-seam) {
    position: absolute;
    top: 0;
    right: -1px;
    bottom: 0;
    left: -1px;
    z-index: 122;
    pointer-events: none;
    background:
      linear-gradient(
        90deg,
        rgba(85, 66, 44, 0.2) 0%,
        rgba(85, 66, 44, 0.34) 20%,
        rgba(80, 64, 42, 0.44) 50%,
        rgba(85, 66, 44, 0.34) 80%,
        rgba(85, 66, 44, 0.2) 100%
      );
    mix-blend-mode: multiply;
    opacity: 0.75;
  }

  /* ============================================ */
  /* TEAR ZONE (visual hint)                       */
  /* ============================================ */

  .tear-zone {
    position: relative;
    z-index: 5;
    padding: 4px 0;
  }

  /* Full-page cut line (fixed across viewport) */
  .page-cut-line {
    position: fixed;
    left: 0;
    top: 0;
    width: 0;
    height: 3px;
    background: linear-gradient(90deg,
      transparent 0%,
      rgba(200,180,160,0.15) 10%,
      rgba(200,180,160,0.35) 30%,
      rgba(220,200,180,0.5) 50%,
      rgba(200,180,160,0.35) 70%,
      rgba(200,180,160,0.15) 90%,
      transparent 100%
    );
    pointer-events: none;
    z-index: 200;
    display: none;
    transform: translateY(-50%);
    border-radius: 1px;
    box-shadow: 0 0 6px 1px rgba(200,180,160,0.15);
    transition: width 0.04s ease-out;
  }

  /* Pieces after tear — wrapper allows washi overflow */
  .receipt-piece {
    overflow: visible !important;
  }

  /* Swipe affordance hint (matches sound-toggle vibe) */
  .cut-hint {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    bottom: calc(72px + env(safe-area-inset-bottom) + var(--vv-bottom-offset, 0px));
    font-family: var(--font-receipt);
    font-size: 10px;
    color: var(--color-btn-default);
    letter-spacing: 1px;
    padding: 6px 14px;
    border: 1px solid var(--color-toolbar-border);
    border-radius: 0;
    background: var(--color-hint-bg);
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    pointer-events: none;
    z-index: 50;
    opacity: 0;
    transition: opacity 0.6s ease;
    white-space: nowrap;
  }

  .cut-hint.visible {
    opacity: 1;
    animation: cutHintPulse 2.5s ease-in-out infinite;
  }

  @keyframes cutHintPulse {
    0%, 100% { opacity: 0.7; }
    50% { opacity: 1; }
  }

  /* ============================================ */
  /* CUT HANDLE (desktop draggable dot)            */
  /* ============================================ */

  /* ============================================ */
  /* CURSOR DOT (inverse blend, desktop only)      */
  /* ============================================ */

  .cursor-dot {
    position: fixed;
    width: var(--dot-size, 8px);
    height: var(--dot-size, 8px);
    border-radius: 50%;
    background: white;
    pointer-events: none;
    z-index: 10200;
    mix-blend-mode: difference;
    opacity: 0;
    transition: opacity 0.15s, width 0.18s ease-out, height 0.18s ease-out;
    transform: translate(-50%, -50%);
  }

  /* Hide on touch devices and small screens */
  @media (pointer: coarse) {
    .cursor-dot { display: none; }
  }
  @media (max-width: 768px) {
    .cursor-dot { display: none; }
  }

  /* Hide OS cursor on desktop */
  @media (pointer: fine) {
    .cursor-dot {
      will-change: left, top, width, height;
    }
    :global(*), :global(*::before), :global(*::after) {
      cursor: none !important;
    }
    :global(body.washi-mode *), :global(body.washi-mode *::before), :global(body.washi-mode *::after) {
      cursor: crosshair !important;
    }
    :global(body.cut-mode *), :global(body.cut-mode *::before), :global(body.cut-mode *::after) {
      cursor: crosshair !important;
    }
    :global(body.hand-mode *), :global(body.hand-mode *::before), :global(body.hand-mode *::after) {
      cursor: grab !important;
    }
    :global(body.hand-mode.hand-dragging *), :global(body.hand-mode.hand-dragging *::before), :global(body.hand-mode.hand-dragging *::after) {
      cursor: grabbing !important;
    }
  }

  :global(body.washi-mode) .cursor-dot,
  :global(body.cut-mode) .cursor-dot,
  :global(body.hand-mode) .cursor-dot {
    display: none;
  }
  :global(body.hand-mode) .receipt-piece,
  :global(body.hand-mode) .receipt-piece > * {
    touch-action: none;
  }

  /* ============================================ */
  /* RESPONSIVE                                    */
  /* ============================================ */

  @media (max-width: 440px) {
    .receipt {
      transform: rotate(0deg);
      padding: 20px 16px;
      width: 100%;
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
      filter: none;
    }

    .receipt::after {
      display: none;
    }

    .receipt-line {
      font-size: 12px;
    }
  }

  @media (max-width: 360px) {
    .receipt-line {
      font-size: 11px;
    }
  }

  @keyframes cut-shimmer {
    to { stroke-dashoffset: -56; }
  }
  @keyframes cut-shimmer-mobile {
    to { stroke-dashoffset: -40; }
  }
</style>

<script>
  // ============================================
  // RECEIPT PRINTER - CLIENT-SIDE LOGIC
  // ============================================

  document.addEventListener('DOMContentLoaded', () => {

    // ========================================
    // 1. SOUND ENGINE (tear sounds only)
    //    Primary: HTML5 Audio (reliable cross-browser)
    //    Enhanced: Web Audio API for zero-latency tear playback
    // ========================================
    class ReceiptSounds {
      private readonly desktopTearFiles = ['/sounds/Tear-1.mp3', '/sounds/Tear-2.mp3', '/sounds/Tear-3.mp3', '/sounds/Tear-4.mp3'];
      private readonly isMobileAudio = window.matchMedia('(pointer: coarse)').matches || /iphone|ipad|ipod|android/i.test(navigator.userAgent);
      private readonly fallbackPoolSize = this.isMobileAudio ? 2 : 4;
      private fallbackPools: HTMLAudioElement[][] = [[], [], [], []];
      private _enabled: boolean = true;
      private audioCtx: AudioContext | null = null;
      private tearBuffers: (AudioBuffer | null)[] = [null, null, null, null];
      private rawBuffers: (ArrayBuffer | null)[] = [null, null, null, null];
      private decodeRequested: boolean[] = [false, false, false, false];
      private tearSequenceIdx: number = 0;
      private _unlocked: boolean = false;
      private _needsGestureReunlock: boolean = false;
      private _tearRetryTimer: ReturnType<typeof setTimeout> | null = null;

      constructor() {
        const saved = localStorage.getItem('aw-sound-enabled');
        if (saved !== null) this._enabled = saved === 'true';

        // Prepare fallback HTMLAudio pools only for active tear files.
        this._activeTearIndices().forEach((idx) => {
          const file = this.desktopTearFiles[idx];
          for (let copy = 0; copy < this.fallbackPoolSize; copy++) {
            const a = new Audio(file);
            a.preload = 'auto';
            a.playsInline = true;
            a.setAttribute('webkit-playsinline', 'true');
            a.volume = 0.5;
            a.load();
            this.fallbackPools[idx].push(a);
          }
        });

        this._initWebAudio();

        // Pre-fetch MP3 data immediately (before any gesture) so decode can start early.
        this._activeTearIndices().forEach((idx) => {
          fetch(this.desktopTearFiles[idx])
            .then(r => r.arrayBuffer())
            .then(buf => { this.rawBuffers[idx] = buf; this._decodeTearBuffers(); })
            .catch(() => {});
        });

        // Persistent unlock listeners for iOS background/foreground recovery
        const unlockFromGesture = () => {
          this._unlocked = true;
          this._attemptUnlock(false);
        };
        ['touchstart', 'touchend', 'click', 'keydown'].forEach((eventName) => {
          document.addEventListener(eventName, unlockFromGesture, { capture: true, passive: true });
        });

        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') {
            this._needsGestureReunlock = true;
            this._attemptUnlock(false);
          }
        });
        window.addEventListener('pageshow', () => {
          this._needsGestureReunlock = true;
          this._attemptUnlock(false);
        });
        window.addEventListener('pagehide', () => {
          this._needsGestureReunlock = true;
        });
      }

      private _activeTearIndices(): number[] {
        return this.isMobileAudio ? [0, 1] : [0, 1, 2, 3];
      }

      private _initWebAudio() {
        try {
          this.audioCtx = new (window.AudioContext || (window as any).webkitAudioContext)();
          this.audioCtx.addEventListener('statechange', () => {
            if (this.audioCtx?.state === 'running') this._decodeTearBuffers();
          });
        } catch(e) {
          this.audioCtx = null;
        }
      }

      private _attemptUnlock(forceKick: boolean) {
        if (!this.audioCtx || this.audioCtx.state === 'closed') return;

        const shouldResume = this.audioCtx.state !== 'running' || this._needsGestureReunlock || forceKick;
        if (shouldResume) {
          this.audioCtx.resume()
            .then(() => {
              if (this.audioCtx?.state === 'running') this._needsGestureReunlock = false;
            })
            .catch(() => {});
          try {
            const silentBuf = this.audioCtx.createBuffer(1, 1, 22050);
            const src = this.audioCtx.createBufferSource();
            src.buffer = silentBuf;
            src.connect(this.audioCtx.destination);
            src.start(0);
            src.stop(0);
          } catch {}
        }

        this._decodeTearBuffers();
      }

      private _hasReadyFallback(tearIdx: number): boolean {
        const pool = this.fallbackPools[tearIdx];
        if (!pool || pool.length === 0) return false;
        return pool.some((candidate) => candidate.readyState >= 2);
      }

      private _scheduleTearRetry(tearIdx: number) {
        if (this._tearRetryTimer) clearTimeout(this._tearRetryTimer);
        this._tearRetryTimer = setTimeout(() => {
          this._tearRetryTimer = null;
          this._attemptUnlock(true);
          if (this._playFromBuffer(tearIdx)) return;
          this._playFromFallbackPool(tearIdx);
        }, 120);
      }

      private _decodeTearBuffers() {
        if (!this.audioCtx || this.audioCtx.state === 'closed') return;
        this._activeTearIndices().forEach((idx) => {
          if (this.tearBuffers[idx] || this.decodeRequested[idx] || !this.rawBuffers[idx]) return;
          this.decodeRequested[idx] = true;
          this.audioCtx!.decodeAudioData(this.rawBuffers[idx]!.slice(0))
            .then(decoded => { this.tearBuffers[idx] = decoded; })
            .catch(err => { console.warn(`[ReceiptSounds] decode buffer ${idx}:`, err); })
            .finally(() => {
              if (!this.tearBuffers[idx]) this.decodeRequested[idx] = false;
            });
        });
      }

      private _playFromBuffer(tearIdx: number): boolean {
        if (!this.audioCtx || this.audioCtx.state !== 'running') return false;
        const buffer = this.tearBuffers[tearIdx];
        if (!buffer) return false;
        const source = this.audioCtx.createBufferSource();
        source.buffer = buffer;
        const gain = this.audioCtx.createGain();
        gain.gain.value = 0.5;
        source.connect(gain);
        gain.connect(this.audioCtx.destination);
        source.start(0);
        return true;
      }

      private _playFromFallbackPool(tearIdx: number, allowAlternate = true): boolean {
        const pool = this.fallbackPools[tearIdx];
        if (!pool || pool.length === 0) return false;

        let audio = pool.find((candidate) => candidate.paused || candidate.ended) || null;
        if (!audio) {
          audio = pool[0] || null;
        }
        if (!audio) {
          if (allowAlternate) {
            const active = this._activeTearIndices();
            const pos = active.indexOf(tearIdx);
            const altIdx = active[(pos + 1) % active.length];
            if (altIdx !== tearIdx) return this._playFromFallbackPool(altIdx, false);
          }
          return false;
        }
        if (!(audio.paused || audio.ended)) {
          audio.pause();
        }

        try { audio.currentTime = 0; } catch {}
        audio.volume = 0.5;
        audio.play().catch(err => {
          console.warn(`[ReceiptSounds] fallback play ${tearIdx}:`, err.message);
          if (!allowAlternate) {
            this._scheduleTearRetry(tearIdx);
            return;
          }
          const active = this._activeTearIndices();
          const pos = active.indexOf(tearIdx);
          const altIdx = active[(pos + 1) % active.length];
          if (altIdx !== tearIdx) {
            const attemptedAlt = this._playFromFallbackPool(altIdx, false);
            if (!attemptedAlt) this._scheduleTearRetry(tearIdx);
            return;
          }
          this._scheduleTearRetry(tearIdx);
        });
        return true;
      }

      get isEnabled() { return this._enabled; }

      toggle() {
        this._enabled = !this._enabled;
        localStorage.setItem('aw-sound-enabled', this._enabled.toString());
        return this._enabled;
      }

      prepareTearGesture() {
        if (!this._enabled) return;
        this._attemptUnlock(true);
      }

      tearSound() {
        if (!this._enabled) return;
        this._attemptUnlock(false);

        const active = this._activeTearIndices();
        const sequencePos = this.tearSequenceIdx % active.length;
        const preferredIdx = active[sequencePos];
        this.tearSequenceIdx++;
        let tearIdx = preferredIdx;

        // Prefer ready source on initial load
        if (!this.tearBuffers[tearIdx]) {
          const readyBufferIdx = active.find((idx) => !!this.tearBuffers[idx]);
          if (readyBufferIdx !== undefined) {
            tearIdx = readyBufferIdx;
          } else {
            const readyFallbackIdx = active.find((idx) => this._hasReadyFallback(idx));
            if (readyFallbackIdx !== undefined) tearIdx = readyFallbackIdx;
          }
        }

        if (this._playFromBuffer(tearIdx)) return;
        if (this._playFromFallbackPool(tearIdx)) return;

        // If nothing is loaded yet (first cuts during initial render), retry once shortly.
        this._scheduleTearRetry(tearIdx);
      }
    }

    const sounds = new ReceiptSounds();

    // ========================================
    // 2. TOP-RIGHT CONTROLS
    // ========================================
    const soundToggle = document.getElementById('soundToggle')!;
    const soundIcon = document.getElementById('soundIcon')!;
    const soundLabel = document.getElementById('soundLabel') as HTMLElement | null;
    const tapeToggle = document.getElementById('tapeToggle') as HTMLButtonElement | null;
    const tapeLabel = document.getElementById('tapeLabel') as HTMLElement | null;
    const clearTapeBtn = document.getElementById('clearTape') as HTMLButtonElement | null;

    const initialEnabled = sounds.isEnabled;
    soundIcon.textContent = initialEnabled ? '\u{1F50A}' : '\u{1F507}';
    soundToggle.classList.toggle('active', initialEnabled);
    let washiMode = false;
    let handMode = false;
    let cutMode = false;
    let cleanupWashiStroke = () => {};
    let cleanupCutStroke = () => {};
    let resetToDefault = () => {};
    const handToggleBtn = document.getElementById('handToggle') as HTMLButtonElement | null;
    const handLabel = document.getElementById('handLabel') as HTMLElement | null;
    const cutToggleBtn = document.getElementById('cutToggle') as HTMLButtonElement | null;
    const cutLabel = document.getElementById('cutLabel') as HTMLElement | null;
    const modeHint = document.getElementById('modeHint') as HTMLElement | null;
    let hintTimer: ReturnType<typeof setTimeout> | null = null;
    let fadeInTimer: ReturnType<typeof setTimeout> | null = null;
    let hintPersistent = false;

    function syncControlLabels() {
      if (soundLabel) soundLabel.textContent = sounds.isEnabled ? 'Sound \u2022 On' : 'Sound \u2022 Off';
      if (tapeLabel) tapeLabel.textContent = washiMode ? 'Washi \u2022 On' : 'Washi \u2022 Off';
      if (handLabel) handLabel.textContent = handMode ? 'Drag \u2022 On' : 'Drag \u2022 Off';
      if (cutLabel) cutLabel.textContent = cutMode ? 'Draw to Cut \u2022 On' : 'Draw to Cut \u2022 Off';
    }

    function showHint(
      text: string,
      persistent: boolean,
      kind: 'default' | 'theme' = 'default',
      instant = false,
      updateMode: 'crossfade' | 'restart' = 'crossfade',
    ) {
      if (!modeHint) return;
      if (hintTimer) { clearTimeout(hintTimer); hintTimer = null; }
      if (fadeInTimer) { clearTimeout(fadeInTimer); fadeInTimer = null; }
      modeHint.classList.toggle('mode-hint--theme', kind === 'theme');

      const scheduleAutoHide = () => {
        hintPersistent = persistent;
        if (!persistent) {
          hintTimer = setTimeout(() => {
            modeHint.classList.remove('visible');
            hintTimer = null;
          }, 1500);
        }
      };

      if (instant) {
        modeHint.textContent = text;
        modeHint.classList.add('visible');
        scheduleAutoHide();
        return;
      }

      if (modeHint.classList.contains('visible')) {
        if (updateMode === 'restart') {
          modeHint.classList.remove('visible');
          modeHint.textContent = text;
          modeHint.getBoundingClientRect(); // Force reflow so opacity transition restarts.
          modeHint.classList.add('visible');
          scheduleAutoHide();
          return;
        }
        // Cross-fade visible hint text to preserve a clear fade-in on updates.
        modeHint.classList.remove('visible');
        fadeInTimer = setTimeout(() => {
          modeHint.textContent = text;
          modeHint.getBoundingClientRect(); // Force reflow so opacity transition restarts.
          modeHint.classList.add('visible');
          fadeInTimer = null;
          scheduleAutoHide();
        }, 120);
      } else {
        modeHint.textContent = text;
        modeHint.getBoundingClientRect(); // Force reflow so opacity transition starts from 0.
        modeHint.classList.add('visible');
        scheduleAutoHide();
      }
    }

    function dismissHint() {
      if (!modeHint || !hintPersistent) return;
      if (fadeInTimer) { clearTimeout(fadeInTimer); fadeInTimer = null; }
      hintPersistent = false;
      modeHint.classList.remove('visible');
    }

    function syncWashiToggle() {
      if (!tapeToggle) return;
      tapeToggle.classList.toggle('active', washiMode);
      document.body.classList.toggle('washi-mode', washiMode);
      if (washiMode && handMode) {
        handMode = false;
        syncHandToggle();
      }
      if (washiMode && cutMode) {
        cutMode = false;
        cleanupCutStroke();
        syncCutToggle();
      }
      // Block scrolling while washi mode is active on mobile
      if (washiMode) {
        document.documentElement.style.touchAction = 'none';
      } else if (!handMode) {
        document.documentElement.style.touchAction = '';
      }
      syncControlLabels();
    }

    function syncHandToggle() {
      if (handToggleBtn) handToggleBtn.classList.toggle('active', handMode);
      document.body.classList.toggle('hand-mode', handMode);
      // Toggle pointer-events on clipEl (first child) — clip-path limits the hit area
      const pe = handMode ? 'auto' : 'none';
      document.querySelectorAll<HTMLElement>('.receipt-piece').forEach(el => {
        const clipChild = el.firstElementChild as HTMLElement | null;
        if (clipChild) clipChild.style.pointerEvents = pe;
      });
      // Block scrolling while hand mode is active on mobile
      if (handMode) {
        document.documentElement.style.touchAction = 'none';
      } else if (!washiMode) {
        document.documentElement.style.touchAction = '';
      }
      syncControlLabels();
    }

    function toggleHandMode() {
      handMode = !handMode;
      if (handMode && washiMode) {
        washiMode = false;
        cleanupWashiStroke();
        syncWashiToggle();
      }
      if (handMode && cutMode) {
        cutMode = false;
        cleanupCutStroke();
        syncCutToggle();
      }
      syncHandToggle();
    }

    function syncCutToggle() {
      if (cutToggleBtn) cutToggleBtn.classList.toggle('active', cutMode);
      document.body.classList.toggle('cut-mode', cutMode);
      if (cutMode && washiMode) {
        washiMode = false;
        cleanupWashiStroke();
        syncWashiToggle();
      }
      if (cutMode && handMode) {
        handMode = false;
        syncHandToggle();
      }
      if (cutMode) {
        document.documentElement.style.touchAction = 'none';
      } else if (!washiMode && !handMode) {
        document.documentElement.style.touchAction = '';
      }
      syncControlLabels();
    }

    function toggleCutMode() {
      cutMode = !cutMode;
      if (!cutMode) cleanupCutStroke();
      syncCutToggle();
    }

    function toggleSound() {
      const enabled = sounds.toggle();
      soundIcon.textContent = enabled ? '\u{1F50A}' : '\u{1F507}';
      soundToggle.classList.toggle('active', enabled);
      syncControlLabels();
    }

    function clearAllTape() {
      document.querySelectorAll('.washi-strip').forEach(el => el.remove());
    }

    const viewport = window.visualViewport;
    const mobileUA = navigator.userAgent || '';
    const isChromeMobile =
      /android/i.test(mobileUA) &&
      /(?:chrome|crios)/i.test(mobileUA) &&
      !/(?:edg|opr|samsungbrowser)/i.test(mobileUA);
    const syncViewportBottomOffset = () => {
      if (!isChromeMobile || !window.matchMedia('(max-width: 600px)').matches || !viewport) {
        document.documentElement.style.setProperty('--vv-bottom-offset', '0px');
        return;
      }
      const scrollTop = document.scrollingElement?.scrollTop ?? window.scrollY;
      if (scrollTop <= 0) {
        document.documentElement.style.setProperty('--vv-bottom-offset', '0px');
        return;
      }
      const viewportBottom = viewport.offsetTop + viewport.height;
      const hiddenUiOffset = Math.max(0, window.innerHeight - viewportBottom);
      const stableOffset = hiddenUiOffset > 1 ? hiddenUiOffset : 0;
      document.documentElement.style.setProperty('--vv-bottom-offset', `${stableOffset.toFixed(2)}px`);
    };
    syncViewportBottomOffset();
    window.addEventListener('resize', syncViewportBottomOffset, { passive: true });
    window.addEventListener('scroll', syncViewportBottomOffset, { passive: true });
    window.addEventListener('orientationchange', syncViewportBottomOffset, { passive: true });
    viewport?.addEventListener('resize', syncViewportBottomOffset);
    viewport?.addEventListener('scroll', syncViewportBottomOffset);

    function flashButton(btn: HTMLElement | null) {
      if (!btn) return;
      btn.classList.add('toolbar-btn--pressed');
      setTimeout(() => btn.classList.remove('toolbar-btn--pressed'), 300);
    }

    let labelTimer: ReturnType<typeof setTimeout> | null = null;
    let activeLabelBtn: HTMLElement | null = null;
    const isMobileHint = window.matchMedia('(max-width: 600px)').matches;

    function showLabelBriefly(btn: HTMLElement | null) {
      if (!btn || isMobileHint) return;
      if (labelTimer) { clearTimeout(labelTimer); labelTimer = null; }
      if (activeLabelBtn && activeLabelBtn !== btn) {
        activeLabelBtn.classList.remove('toolbar-btn--label-show');
      }
      document.querySelectorAll('.toolbar-btn.toolbar-btn--label-show').forEach((el) => {
        if (el !== btn) el.classList.remove('toolbar-btn--label-show');
      });
      btn.classList.add('toolbar-btn--label-show');
      activeLabelBtn = btn;
      labelTimer = setTimeout(() => {
        btn.classList.remove('toolbar-btn--label-show');
        if (activeLabelBtn === btn) activeLabelBtn = null;
        labelTimer = null;
      }, 900);
    }

    soundToggle.addEventListener('click', () => {
      toggleSound();
      showLabelBriefly(soundToggle);
      if (isMobileHint) showHint(sounds.isEnabled ? 'Sound \u2022 On' : 'Sound \u2022 Off', false);
    });

    tapeToggle?.addEventListener('click', () => {
      washiMode = !washiMode;
      syncWashiToggle();
      showLabelBriefly(tapeToggle);
      if (isMobileHint) {
        showHint(washiMode ? 'Washi \u2022 On \u00B7 Scroll Disabled' : 'Washi \u2022 Off', washiMode);
      }
    });

    clearTapeBtn?.addEventListener('click', () => {
      clearAllTape();
      showLabelBriefly(clearTapeBtn);
      if (isMobileHint) showHint('Tape Cleared', false);
    });

    handToggleBtn?.addEventListener('click', () => {
      toggleHandMode();
      showLabelBriefly(handToggleBtn);
      if (isMobileHint) {
        showHint(handMode ? 'Drag \u2022 On \u00B7 Scroll Disabled' : 'Drag \u2022 Off', handMode);
      }
    });

    cutToggleBtn?.addEventListener('click', () => {
      toggleCutMode();
      showLabelBriefly(cutToggleBtn);
      if (isMobileHint) {
        showHint(cutMode ? 'Draw to Cut \u2022 On \u00B7 Scroll Disabled' : 'Draw to Cut \u2022 Off', cutMode);
      }
    });

    const resetBtn = document.getElementById('resetBtn') as HTMLButtonElement | null;
    resetBtn?.addEventListener('click', () => {
      resetToDefault();
      if (isMobileHint) showHint('Reset', false);
    });

    syncWashiToggle();
    syncControlLabels();

    // ========================================
    // 2a. COLOR THEME CYCLING
    // ========================================
    let tearTextureCache: string[] = [];
    const THEMES = ['parchment', 'midnight', 'carbon', 'terracotta', 'forest'] as const;
    let themeTransitionInFlight = false;
    const themeToggleBtn = document.getElementById('themeToggle') as HTMLButtonElement | null;
    const themeLabel = document.getElementById('themeLabel') as HTMLElement | null;

    function getCurrentTheme(): string {
      return document.documentElement.dataset.theme || 'parchment';
    }

    function applyTheme(name: string) {
      if (name === 'parchment') {
        delete document.documentElement.dataset.theme;
      } else {
        document.documentElement.dataset.theme = name;
      }
      localStorage.setItem('aw-theme', name);
      if (themeLabel) themeLabel.textContent = name.charAt(0).toUpperCase() + name.slice(1);
    }

    function getNextThemeName(current = getCurrentTheme()): string {
      const currentIdx = THEMES.indexOf(current as typeof THEMES[number]);
      const nextIdx = (currentIdx + 1) % THEMES.length;
      return THEMES[nextIdx];
    }

    function cycleTheme(next = getNextThemeName()) {
      const finishTransition = () => {
        themeTransitionInFlight = false;
      };

      themeTransitionInFlight = true;

      const btn = themeToggleBtn;
      if (!btn) {
        applyTheme(next);
        refreshCanvasElements();
        finishTransition();
        return;
      }

      const rect = btn.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      const maxRadius = Math.hypot(
        Math.max(cx, window.innerWidth - cx),
        Math.max(cy, window.innerHeight - cy)
      );
      if (!document.startViewTransition) {
        applyTheme(next);
        refreshCanvasElements();
        finishTransition();
        return;
      }

      document.documentElement.classList.add('theme-transitioning');

      let transition: any;
      try {
        transition = document.startViewTransition(() => {
          applyTheme(next);
        });
      } catch {
        document.documentElement.classList.remove('theme-transitioning');
        applyTheme(next);
        refreshCanvasElements();
        finishTransition();
        return;
      }

      transition.ready.then(() => {
        const feather = 80;
        const frames: Keyframe[] = [];
        const steps = 20;
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
          const r = eased * (maxRadius + feather);
          const inner = Math.max(0, r - feather);
          frames.push({
            maskImage: `radial-gradient(circle at ${cx}px ${cy}px, black ${inner}px, transparent ${r}px)`,
            offset: t,
          });
        }
        document.documentElement.animate(frames, {
          duration: 650,
          easing: 'linear',
          pseudoElement: '::view-transition-new(root)',
        });
      });

      transition.finished
        .catch(() => {
          // Ignore transition rejections and run shared cleanup below.
        })
        .finally(() => {
          document.documentElement.classList.remove('theme-transitioning');
          refreshCanvasElements();
          finishTransition();
        });
    }

    function getThemeColor(prop: string): string {
      return getComputedStyle(document.documentElement).getPropertyValue(prop).trim();
    }

    function refreshCanvasElements() {
      const paperColor = getThemeColor('--color-paper');
      const inkColor = getThemeColor('--color-ink');

      // Re-generate barcode with new theme colors
      const barcodeImg = document.querySelector('#barcodeCanvas') as HTMLImageElement | null;
      if (barcodeImg && barcodeImg.tagName === 'IMG') {
        const tmpCanvas = document.createElement('canvas');
        tmpCanvas.width = 200;
        tmpCanvas.height = 50;
        generateBarcode(tmpCanvas, daysAlive, paperColor, inkColor);
        barcodeImg.src = tmpCanvas.toDataURL('image/png');

        // Update barcode in any torn pieces
        document.querySelectorAll<HTMLImageElement>('.receipt-piece img.barcode-img, .receipt-piece [id="barcodeCanvas"]')
          .forEach(img => { img.src = barcodeImg.src; });
      }

      // Clear tear texture cache so future tears use new theme colors
      tearTextureCache = [];
    }

    themeToggleBtn?.addEventListener('click', () => {
      if (themeTransitionInFlight) return;

      const nextTheme = getNextThemeName();
      cycleTheme(nextTheme);
      if (isMobileHint) {
        // Let View Transition capture old/new states first, then fade the label in.
        requestAnimationFrame(() => {
          showHint(nextTheme.charAt(0).toUpperCase() + nextTheme.slice(1), false, 'theme', false, 'restart');
        });
      }
    });

    // Initialize theme label from stored preference
    const storedTheme = localStorage.getItem('aw-theme') || 'parchment';
    if (themeLabel) themeLabel.textContent = storedTheme.charAt(0).toUpperCase() + storedTheme.slice(1);

    // ========================================
    // 2b. DYNAMIC DATE & ORDER NUMBER
    // ========================================
    const now = new Date();
    const pad = (n: number) => n.toString().padStart(2, '0');
    const dateStr = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}`;
    const timeStr = `${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
    
    const receiptDateEl = document.getElementById('receiptDate');
    if (receiptDateEl) receiptDateEl.textContent = `${dateStr}  ${timeStr}`;

    // Order number: days since June 15, 1992
    const birthDate = new Date(1992, 5, 15);
    const daysAlive = Math.floor((now.getTime() - birthDate.getTime()) / (1000 * 60 * 60 * 24));
    const receiptOrderEl = document.getElementById('receiptOrder');
    if (receiptOrderEl) receiptOrderEl.textContent = daysAlive.toString();

    // Barcode number
    const barcodeNumberEl = document.getElementById('barcodeNumber');
    if (barcodeNumberEl) {
      const orderStr = daysAlive.toString().padStart(12, '0');
      barcodeNumberEl.textContent = `${orderStr.slice(0,4)} ${orderStr.slice(4,8)} ${orderStr.slice(8,12)}`;
    }

    // Visitor counter (Vercel KV/Redis)
    const visitorCountEl = document.getElementById('visitorCount');
    if (visitorCountEl) {
      const isNewSession = !sessionStorage.getItem('aw-session');

      // Clear old localStorage value
      localStorage.removeItem('aw-visitor-count');

      const endpoint = isNewSession
        ? '/api/visitor-count?increment=true'
        : '/api/visitor-count';

      fetch(endpoint)
        .then(res => res.json())
        .then(data => {
          const count = data.count || 0;
          visitorCountEl.textContent = count.toString().padStart(5, '0');

          if (isNewSession) {
            sessionStorage.setItem('aw-session', '1');
          }
        })
        .catch(() => {
          visitorCountEl.textContent = '00000';
        });
    }

    // ========================================
    // 3. FLOYD-STEINBERG DITHERING
    // ========================================
    function ditherImage(canvas: HTMLCanvasElement, imageSrc: string) {
      const ctx = canvas.getContext('2d')!;
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.src = imageSrc;

      img.onload = () => {
        const ditherWidth = 160;
        const ditherHeight = Math.round((img.height / img.width) * ditherWidth);

        canvas.width = ditherWidth;
        canvas.height = ditherHeight;

        ctx.drawImage(img, 0, 0, ditherWidth, ditherHeight);
        const imageData = ctx.getImageData(0, 0, ditherWidth, ditherHeight);
        const data = imageData.data;

        // Convert to grayscale first
        for (let i = 0; i < data.length; i += 4) {
          const gray = data[i] * 0.299 + data[i+1] * 0.587 + data[i+2] * 0.114;
          data[i] = data[i+1] = data[i+2] = gray;
        }

        // Floyd-Steinberg dithering
        for (let y = 0; y < ditherHeight; y++) {
          for (let x = 0; x < ditherWidth; x++) {
            const idx = (y * ditherWidth + x) * 4;
            const oldVal = data[idx];
            const newVal = oldVal > 128 ? 255 : 0;
            const error = oldVal - newVal;

            data[idx] = data[idx+1] = data[idx+2] = newVal;

            // Distribute error to neighbors
            if (x + 1 < ditherWidth) {
              const i = (y * ditherWidth + x + 1) * 4;
              data[i] = data[i+1] = data[i+2] = clamp(data[i] + error * 7/16);
            }
            if (y + 1 < ditherHeight) {
              if (x - 1 >= 0) {
                const i = ((y+1) * ditherWidth + x - 1) * 4;
                data[i] = data[i+1] = data[i+2] = clamp(data[i] + error * 3/16);
              }
              {
                const i = ((y+1) * ditherWidth + x) * 4;
                data[i] = data[i+1] = data[i+2] = clamp(data[i] + error * 5/16);
              }
              if (x + 1 < ditherWidth) {
                const i = ((y+1) * ditherWidth + x + 1) * 4;
                data[i] = data[i+1] = data[i+2] = clamp(data[i] + error * 1/16);
              }
            }
          }
        }

        ctx.putImageData(imageData, 0, 0);

        // Convert canvas to <img> so cloneNode preserves the rendered image
        // (canvas pixel data is not cloned by cloneNode)
        const dataUrl = canvas.toDataURL('image/png');
        const replacement = document.createElement('img');
        replacement.src = dataUrl;
        replacement.alt = 'Andrew Washuta';
        replacement.className = 'portrait-img';
        canvas.replaceWith(replacement);
      };

      img.onerror = () => {
        // Fallback: just show a placeholder
        canvas.width = 160;
        canvas.height = 160;
        ctx.fillStyle = getThemeColor('--color-paper');
        ctx.fillRect(0, 0, 160, 160);
        ctx.fillStyle = getThemeColor('--color-ink');
        ctx.font = '14px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('[PORTRAIT]', 80, 80);
      };
    }

    function clamp(val: number): number {
      return Math.min(255, Math.max(0, val));
    }

    // Initialize portrait dithering
    const portraitContainer = document.querySelector('.portrait-container') as HTMLElement;
    const canvas = document.getElementById('portraitCanvas') as HTMLCanvasElement;
    if (portraitContainer && canvas) {
      const src = portraitContainer.dataset.src;
      if (src) {
        ditherImage(canvas, src);
      }
    }

    // ========================================
    // 3b. BARCODE GENERATION
    // ========================================
    function generateBarcode(canvas: HTMLCanvasElement, value: number, bgColor?: string, fgColor?: string) {
      const ctx = canvas.getContext('2d')!;
      const w = canvas.width;
      const h = canvas.height;

      ctx.fillStyle = bgColor || getThemeColor('--color-paper');
      ctx.fillRect(0, 0, w, h);

      // Calculate total barcode width first to center it
      const seed = value.toString();
      const digits = seed.padStart(12, '0');
      const patterns = [
        [3,2,1,1], [2,2,2,1], [2,1,2,2], [1,4,1,1], [1,1,3,2],
        [1,2,3,1], [1,1,1,4], [1,3,1,2], [1,2,1,3], [3,1,1,2]
      ];

      let totalWidth = 8; // start guard: 3 bars + 2 spaces = 8px
      for (let d = 0; d < digits.length; d++) {
        const digit = parseInt(digits[d]);
        const pattern = patterns[digit];
        totalWidth += pattern.reduce((a, b) => a + b, 0) + 1; // pattern + 1px gap
        if (d === 5) totalWidth += 10; // middle guard
      }
      totalWidth += 8; // end guard

      const barHeight = h - 10;
      const startY = 5;
      let x = (w - totalWidth) / 2; // center the barcode

      ctx.fillStyle = fgColor || getThemeColor('--color-ink');

      // Start guard pattern
      for (let g = 0; g < 3; g++) {
        ctx.fillRect(x, startY, 1, barHeight);
        x += 2;
      }
      x += 2;

      // Generate bars from order number digits
      for (let d = 0; d < digits.length; d++) {
        const digit = parseInt(digits[d]);
        const pattern = patterns[digit];
        for (let p = 0; p < pattern.length; p++) {
          if (p % 2 === 0) {
            ctx.fillRect(x, startY, pattern[p], barHeight);
          }
          x += pattern[p];
        }
        x += 1;

        // Middle guard
        if (d === 5) {
          x += 2;
          for (let g = 0; g < 3; g++) {
            ctx.fillRect(x, startY, 1, barHeight);
            x += 2;
          }
          x += 2;
        }
      }

      // End guard pattern
      x += 2;
      for (let g = 0; g < 3; g++) {
        ctx.fillRect(x, startY, 1, barHeight);
        x += 2;
      }
    }

    const barcodeCanvas = document.getElementById('barcodeCanvas') as HTMLCanvasElement;
    if (barcodeCanvas) {
      generateBarcode(barcodeCanvas, daysAlive);

      // Convert canvas to <img> so cloneNode preserves the rendered barcode
      // (canvas pixel data is not cloned by cloneNode)
      const barcodeDataUrl = barcodeCanvas.toDataURL('image/png');
      const barcodeImg = document.createElement('img');
      barcodeImg.src = barcodeDataUrl;
      barcodeImg.alt = 'Barcode';
      barcodeImg.id = barcodeCanvas.id;
      barcodeImg.width = barcodeCanvas.width;
      barcodeImg.height = barcodeCanvas.height;
      barcodeCanvas.replaceWith(barcodeImg);
    }

    // ========================================
    // 3c. RANDOM PRINT ARTIFACTS
    // ========================================
    // Add subtle horizontal misalignment to ~15% of lines for authenticity
    const allLines = document.querySelectorAll('.receipt-line') as NodeListOf<HTMLElement>;
    allLines.forEach((line) => {
      if (Math.random() < 0.12) {
        const offset = (Math.random() - 0.5) * 1.2; // -0.6 to +0.6 px
        line.style.transform = `translateX(${offset}px)`;
      }
    });

    // ========================================
    // 4. PRINTING ANIMATION
    // ========================================
    const allPrintables = document.querySelectorAll('[data-print]') as NodeListOf<HTMLElement>;
    let printIndex = 0;
    let isPrinting = false;
    let printTimeout: ReturnType<typeof setTimeout> | null = null;
    const MIN_LINES_BEFORE_CUT = 8;
    function canCutDuringPrint(): boolean {
      return !isPrinting || printIndex >= MIN_LINES_BEFORE_CUT;
    }

    // Callback set by tear system to mirror class changes to clone pieces
    let mirrorPrintState: ((index: number, addClasses: string[], removeClasses: string[]) => void) | null = null;

    function printNextLine() {
      if (printIndex >= allPrintables.length) {
        finishPrinting();
        return;
      }

      const line = allPrintables[printIndex];

      // Remove cursor from previous line
      if (printIndex > 0) {
        allPrintables[printIndex - 1].classList.remove('printing');
        mirrorPrintState?.(printIndex - 1, [], ['printing']);
      }

      // Print this line
      line.classList.add('printed');
      line.classList.add('printing');
      mirrorPrintState?.(printIndex, ['printed', 'printing'], []);

      printIndex++;

      if (printIndex === MIN_LINES_BEFORE_CUT) {
        setTimeout(showCutHint, 800);
      }

      // Vary delay for different line types for authentic feel
      let delay = 40;
      const text = line.textContent || '';

      if (text.includes('====') || text.includes('----')) {
        delay = 55;
      } else if (line.classList.contains('spacer') || text.trim() === '') {
        delay = 12;
      } else if (line.classList.contains('big')) {
        delay = 70;
      } else if (line.classList.contains('portrait-container') || line.classList.contains('barcode-container')) {
        delay = 350;
      } else if (line.classList.contains('bold')) {
        delay = 50;
      }

      printTimeout = setTimeout(printNextLine, delay);
    }

    // ========================================
    // CUT HINT / SWIPE AFFORDANCE
    // ========================================
    let cutHintEl: HTMLElement | null = null;
    let cutHintTimer: ReturnType<typeof setTimeout> | null = null;

    function showCutHint() {
      // Always show on first visit (cleared localStorage key)
      if (sessionStorage.getItem('aw-hint-shown')) return;
      sessionStorage.setItem('aw-hint-shown', '1');

      if (isMobileHint) {
        showHint('Swipe to Tear', true);
        return;
      }

      cutHintEl = document.createElement('div');
      cutHintEl.className = 'cut-hint';
      cutHintEl.textContent = window.matchMedia('(pointer: fine)').matches
        ? '[ CLICK & DRAG TO TEAR ]'
        : '[ SWIPE TO TEAR ]';
      document.body.appendChild(cutHintEl);

      // Force reflow before adding class so transition fires
      cutHintEl.getBoundingClientRect();

      // Fade in after brief pause
      setTimeout(() => {
        if (cutHintEl) cutHintEl.classList.add('visible');
      }, 600);

      // Auto-dismiss after 8 seconds
      cutHintTimer = setTimeout(() => {
        if (cutHintEl) {
          cutHintEl.classList.remove('visible');
          setTimeout(() => { cutHintEl?.remove(); cutHintEl = null; }, 600);
        }
      }, 8000);
    }

    function dismissCutHint() {
      if (cutHintTimer) { clearTimeout(cutHintTimer); cutHintTimer = null; }
      if (cutHintEl) {
        cutHintEl.classList.remove('visible');
        setTimeout(() => { cutHintEl?.remove(); cutHintEl = null; }, 600);
      }
    }

    function finishPrinting() {
      isPrinting = false;

      // Remove any remaining cursor
      allPrintables.forEach(el => el.classList.remove('printing'));

      for (let i = 0; i < allPrintables.length; i++) {
        mirrorPrintState?.(i, [], ['printing']);
      }

    }

    function startPrinting() {
      if (isPrinting) return;
      isPrinting = true;

      printTimeout = setTimeout(printNextLine, 200);
    }

    // ========================================
    // 5. RANDOM ROTATION (subtle authenticity)
    // ========================================
    const receipt = document.getElementById('receipt');
    if (receipt) {
      const rotation = -0.8 + Math.random() * 1.6; // -0.8 to +0.8 degrees
      receipt.style.transform = `rotate(${rotation}deg)`;
    }

    // ========================================
    // 5b. CURSOR DOT (inverse blend, desktop only)
    //     with lerp/inertia for trailing lag
    // ========================================
    const cursorDot = document.getElementById('cursorDot');
    let dotTargetX = 0;
    let dotTargetY = 0;
    let dotCurrentX = 0;
    let dotCurrentY = 0;
    let dotVisible = false;
    let dotAnimating = false;
    const DOT_LERP = 0.35;
    const DOT_SIZE_MIN = 8;
    const DOT_SIZE_MAX = 16;
    const PROXIMITY_RANGE = 80;
    const CUT_EDGE_SAFETY = 10;
    const CUT_EDGE_PADDING = 30;

    if (cursorDot && window.matchMedia('(pointer: fine)').matches) {
      document.addEventListener('mousemove', (e: MouseEvent) => {
        dotTargetX = e.clientX;
        dotTargetY = e.clientY;

        if (!dotVisible) {
          dotCurrentX = dotTargetX;
          dotCurrentY = dotTargetY;
          cursorDot.style.left = dotCurrentX + 'px';
          cursorDot.style.top = dotCurrentY + 'px';
          cursorDot.style.opacity = '1';
          dotVisible = true;
        }

        if (!dotAnimating) {
          dotAnimating = true;
          requestAnimationFrame(dotLerp);
        }
      });

      function dotLerp() {
        dotCurrentX += (dotTargetX - dotCurrentX) * DOT_LERP;
        dotCurrentY += (dotTargetY - dotCurrentY) * DOT_LERP;

        cursorDot!.style.left = dotCurrentX + 'px';
        cursorDot!.style.top = dotCurrentY + 'px';

        const dx = Math.abs(dotTargetX - dotCurrentX);
        const dy = Math.abs(dotTargetY - dotCurrentY);
        if (dx > 0.5 || dy > 0.5) {
          requestAnimationFrame(dotLerp);
        } else {
          dotCurrentX = dotTargetX;
          dotCurrentY = dotTargetY;
          cursorDot!.style.left = dotCurrentX + 'px';
          cursorDot!.style.top = dotCurrentY + 'px';
          dotAnimating = false;
        }
      }

      document.addEventListener('mouseleave', () => {
        cursorDot.style.opacity = '0';
        dotVisible = false;
        dotAnimating = false;
      });
    }

    // ========================================
    // 6. TEAR INTERACTION
    //    - Swipe horizontally ANYWHERE on the page
    //    - Multiple tears allowed
    //    - Pieces separate and stay visible
    // ========================================

    if (receipt) {
      const TEAR_GAP = 22; // px of separation per tear

      // Each piece tracks its polygon clip shape, offset, and edge info
      type JaggedEdge = number[]; // perpendicular offset values in px, evenly spaced along edge
      type Point = { x: number; y: number }; // percentage coordinates (0-100) within receipt
      type EdgeInfo = { jagged: JaggedEdge | null; source?: 'cut' | 'tear'; cutGen?: number };
      let cutGeneration = 0;

      type TearPiece = {
        el: HTMLElement;              // wrapper div (positioned, draggable, washi goes here)
        clipEl: HTMLElement;          // inner div (clipped receipt content)
        polygon: Point[];             // clockwise vertices in receipt percentage coords
        edges: EdgeInfo[];            // edges[i] = edge from polygon[i] to polygon[(i+1) % n]
        offsetX: number;  // accumulated horizontal px offset
        offsetY: number;  // accumulated vertical px offset
        rotation: number; // accumulated rotation offset (degrees)
        printables: HTMLElement[];     // cached [data-print] elements in this clone
      };

      function polyTop(p: TearPiece): number { return Math.min(...p.polygon.map(v => v.y)); }
      function polyBottom(p: TearPiece): number { return Math.max(...p.polygon.map(v => v.y)); }

      let pieces: TearPiece[] = [];
      let tearSystemReady = false;
      let baseRotation = 0;
      let receiptH = 0;
      const desktopFinePointer = window.matchMedia('(pointer: fine)').matches;

      type TapeStroke = {
        startX: number;
        startY: number;
        endX: number;
        endY: number;
      };

      let washiDrawing = false;
      let washiStartX = 0;
      let washiStartY = 0;
      let washiCurrentX = 0;
      let washiCurrentY = 0;
      let washiStartScrollX = 0;
      let washiStartScrollY = 0;
      const usePointerWashi = typeof window !== 'undefined' && 'PointerEvent' in window;
      let activeWashiPointerId: number | null = null;
      const MIN_WASHI_STROKE = 10;
      let washiPreviewClip = 'polygon(0% 0%, 0% 100%, 100% 100%, 100% 0%)';
      const washiPreview = document.createElement('div');
      washiPreview.className = 'washi-preview';
      const washiOverlay = document.createElement('div');
      washiOverlay.className = 'washi-overlay';
      const receiptWrapper = receipt!.parentElement as HTMLElement;
      if (getComputedStyle(receiptWrapper).position === 'static') {
        receiptWrapper.style.position = 'relative';
      }
      Object.assign(washiOverlay.style, {
        position: 'absolute',
        left: '0',
        top: '0',
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
        zIndex: '10050',
      });
      receiptWrapper.appendChild(washiOverlay);
      document.body.appendChild(washiPreview);

      function clampPct(v: number, min: number, max: number): number {
        return Math.max(min, Math.min(max, v));
      }

      function createWashiClipPath(): string {
        const segments = 7;
        let s = Math.floor(Math.random() * 2147483647) || 17;
        const rand = () => {
          s = (s * 48271) % 2147483647;
          return s / 2147483647;
        };

        const left: string[] = [];
        const right: string[] = [];
        for (let i = 0; i <= segments; i++) {
          const y = (i / segments) * 100;
          const lx = 1.2 + rand() * 6.5;
          const rx = 98.8 - rand() * 6.5;
          left.push(`${lx.toFixed(2)}% ${y.toFixed(2)}%`);
          right.push(`${rx.toFixed(2)}% ${y.toFixed(2)}%`);
        }
        right.reverse();
        return `polygon(${left.join(', ')}, ${right.join(', ')})`;
      }

      function hideWashiPreview() {
        washiPreview.style.display = 'none';
        washiPreview.style.width = '0';
      }

      cleanupWashiStroke = () => {
        if (washiDrawing) {
          activeWashiPointerId = null;
          washiDrawing = false;
          hideWashiPreview();
        }
      };

      resetToDefault = () => {
        pieces.forEach(p => p.el.remove());
        pieces = [];
        tearSystemReady = false;
        baseRotation = 0;
        receiptH = 0;

        receipt!.style.visibility = '';
        receipt!.style.boxShadow = '';
        receipt!.style.filter = '';
        receipt!.parentElement!.style.paddingBottom = '';

        washiDrawing = false;
        activeWashiPointerId = null;
        hideWashiPreview();

        document.querySelectorAll('.washi-strip, .tape-seam').forEach(el => el.remove());

        physicsQueue = [];
        handPhysicsActive = false;
        handDragging = false;
        handDragPiece = null;
        activeHandPointerId = null;
        handZCounter = 20;

        if (washiMode) { washiMode = false; syncWashiToggle(); }
        if (handMode) { handMode = false; syncHandToggle(); }
        if (cutMode) { cutMode = false; cleanupCutStroke(); syncCutToggle(); }
      };

      function updateWashiPreview() {
        const scrollDX = window.scrollX - washiStartScrollX;
        const scrollDY = window.scrollY - washiStartScrollY;
        const adjStartX = washiStartX - scrollDX;
        const adjStartY = washiStartY - scrollDY;
        const dx = washiCurrentX - adjStartX;
        const dy = washiCurrentY - adjStartY;
        const len = Math.hypot(dx, dy);
        if (len < 2) {
          hideWashiPreview();
          return;
        }

        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        const midX = (adjStartX + washiCurrentX) / 2;
        const midY = (adjStartY + washiCurrentY) / 2;

        washiPreview.style.display = 'block';
        washiPreview.style.left = `${midX}px`;
        washiPreview.style.top = `${midY}px`;
        washiPreview.style.width = `${len + 12}px`;
        washiPreview.style.height = `${20}px`;
        washiPreview.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
        washiPreview.style.clipPath = washiPreviewClip;
      }

      // Wire up print state mirroring to clone pieces
      mirrorPrintState = (index, addClasses, removeClasses) => {
        if (!tearSystemReady) return;
        for (const piece of pieces) {
          const target = piece.printables[index];
          if (!target) continue;
          for (const cls of addClasses) target.classList.add(cls);
          for (const cls of removeClasses) target.classList.remove(cls);
        }
      };

      // Generate irregular jagged edge simulating perforated paper tear
      function generateJaggedEdge(): JaggedEdge {
        const numPoints = 80;
        const edge: number[] = [];
        for (let i = 0; i <= numPoints; i++) {
          const t = i / numPoints;
          // Organic waviness from overlapping sine waves
          const wave = Math.sin(t * Math.PI * 6) * 1.2
                     + Math.sin(t * Math.PI * 13 + 1.7) * 0.8;
          // Random teeth: 2-4px irregular triangular variations
          const tooth = (Math.random() - 0.5) * 5;
          edge.push(wave + tooth);
        }
        return edge;
      }

      // Convert jagged edge data to polygon point strings along an arbitrary edge
      function jaggedEdgePoints(edge: JaggedEdge, from: Point, to: Point): string[] {
        // For now, jagged offsets are applied perpendicular to the edge.
        // For horizontal edges (the only kind in tear mode), perpendicular = vertical.
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        const len = Math.hypot(dx, dy);
        // Normal direction (perpendicular, rotated 90° clockwise)
        const nx = len > 0 ? -dy / len : 0;
        const ny = len > 0 ? dx / len : 1;

        return edge.map((offsetPx, i) => {
          const t = i / (edge.length - 1);
          const x = from.x + dx * t + nx * (offsetPx / receiptH) * 100;
          const y = from.y + dy * t + ny * (offsetPx / receiptH) * 100;
          return `${x.toFixed(2)}% ${y.toFixed(2)}%`;
        });
      }

      // Full-viewport cut line
      const pageCutLine = document.createElement('div');
      pageCutLine.className = 'page-cut-line';
      document.body.appendChild(pageCutLine);

      // Format a polygon point, with overflow at receipt extremes to prevent subpixel gaps
      function fmtClipPt(x: number, y: number): string {
        if (y <= 0) y = -2;
        if (y >= 100) y = 102;
        return `${x.toFixed(2)}% ${y.toFixed(2)}%`;
      }

      // Build clip-path polygon for a piece by walking its polygon vertices + edges
      function clipFor(p: TearPiece): string {
        const points: string[] = [];
        for (let i = 0; i < p.polygon.length; i++) {
          const from = p.polygon[i];
          const to = p.polygon[(i + 1) % p.polygon.length];
          const edge = p.edges[i];

          if (edge.jagged) {
            // Emit jagged points along this edge, excluding the last point
            // (it's the start of the next edge)
            const jpts = jaggedEdgePoints(edge.jagged, from, to);
            for (let j = 0; j < jpts.length - 1; j++) {
              points.push(jpts[j]);
            }
          } else {
            // Clean edge: just emit the start vertex
            points.push(fmtClipPt(from.x, from.y));
          }
        }
        return `polygon(${points.join(', ')})`;
      }

      function transformFor(p: TearPiece): string {
        return `translateX(-50%) translateX(${p.offsetX}px) rotate(${baseRotation + p.rotation}deg) translateY(${p.offsetY}px)`;
      }

      const PIECE_SHADOW = desktopFinePointer
        ? 'drop-shadow(0 2px 4px rgba(0,0,0,0.1)) drop-shadow(0 4px 12px rgba(0,0,0,0.12))'
        : 'drop-shadow(0 2px 6px rgba(0,0,0,0.15))';

      // Lazily set up the piece system on the first tear
      function initTearSystem() {
        if (tearSystemReady) return;
        tearSystemReady = true;

        const wrapper = receipt!.parentElement!;
        wrapper.style.position = 'relative';

        // Capture the current rotation and height
        const m = receipt!.style.transform?.match(/rotate\(([^)]+)deg\)/);
        baseRotation = m ? parseFloat(m[1]) : 0;
        receiptH = receipt!.offsetHeight;

        // Create the initial full-receipt piece as a rectangle polygon
        const initPoly: Point[] = [{x:0,y:0}, {x:100,y:0}, {x:100,y:100}, {x:0,y:100}];
        const initEdges: EdgeInfo[] = [{jagged:null}, {jagged:null}, {jagged:null}, {jagged:null}];
        const { el, clipEl, printables } = makePieceEl(initPoly, initEdges, 0, 0, 0);
        wrapper.appendChild(el);
        pieces.push({ el, clipEl, polygon: initPoly, edges: initEdges, offsetX: 0, offsetY: 0, rotation: 0, printables });

        // Hide the original (it stays in flow for layout height)
        receipt!.style.visibility = 'hidden';
        receipt!.style.boxShadow = 'none';
        receipt!.style.filter = 'none';
      }

      // ---- Canvas-generated paper fiber noise textures ----

      function generateFiberTexture(width: number, height: number, seed: number): string {
        const c = document.createElement('canvas');
        c.width = width;
        c.height = height;
        const ctx = c.getContext('2d')!;

        ctx.clearRect(0, 0, width, height);

        // Seeded pseudo-random for reproducibility within a tear
        let s = seed;
        const rand = () => { s = (s * 16807 + 0) % 2147483647; return (s & 0x7fffffff) / 0x7fffffff; };

        const imgData = ctx.createImageData(width, height);
        const d = imgData.data;

        // Layer 1: Base noise — random grayscale speckle
        for (let i = 0; i < d.length; i += 4) {
          const px = (i / 4) % width;
          const py = Math.floor((i / 4) / width);
          const centerDist = Math.abs(py - height / 2) / (height / 2);

          // Stronger noise near the center (the tear line), fading at edges
          const edgeFade = 1 - centerDist * centerDist;
          const noiseVal = rand();

          // High-contrast binary noise with some mid-tones
          let gray: number;
          if (noiseVal < 0.35 * edgeFade) {
            gray = 40 + rand() * 60; // dark speckles
          } else if (noiseVal < 0.5 * edgeFade) {
            gray = 120 + rand() * 50; // mid-tone grain
          } else {
            gray = 0; // transparent (will be set via alpha)
          }

          const alpha = noiseVal < 0.5 * edgeFade ? (180 * edgeFade + rand() * 75) : 0;
          d[i] = gray;
          d[i + 1] = gray;
          d[i + 2] = gray;
          d[i + 3] = Math.min(255, alpha);

          // Occasional horizontal fiber streaks
          if (rand() < 0.008 * edgeFade) {
            const streakLen = 3 + Math.floor(rand() * 8);
            const streakGray = 30 + rand() * 70;
            for (let sx = 0; sx < streakLen && px + sx < width; sx++) {
              const si = ((py * width) + px + sx) * 4;
              d[si] = streakGray;
              d[si + 1] = streakGray;
              d[si + 2] = streakGray;
              d[si + 3] = Math.min(255, 160 * edgeFade + rand() * 90);
            }
          }
        }
        ctx.putImageData(imgData, 0, 0);

        // Layer 2: Scattered larger fiber clumps
        for (let i = 0; i < 20; i++) {
          const fx = rand() * width;
          const fy = height * 0.3 + rand() * height * 0.4;
          const fw = 1 + rand() * 4;
          const fh = 1 + rand() * 2;
          const fAlpha = 0.15 + rand() * 0.35;
          const fR = parseFloat(getThemeColor('--color-fiber-r')) || 80;
          const fG = parseFloat(getThemeColor('--color-fiber-g')) || 65;
          const fB = parseFloat(getThemeColor('--color-fiber-b')) || 50;
          ctx.fillStyle = `rgba(${fR - 30 + rand() * 60}, ${fG - 25 + rand() * 50}, ${fB - 20 + rand() * 40}, ${fAlpha})`;
          ctx.fillRect(fx, fy, fw, fh);
        }

        return c.toDataURL('image/png');
      }

      // Pre-generate a few textures to avoid re-creating per tear
      const _texW = 400;
      const _texH = 24;
      function getTearTexture(seed: number): string {
        const idx = seed % 6;
        if (!tearTextureCache[idx]) {
          tearTextureCache[idx] = generateFiberTexture(_texW, _texH, seed * 7919 + idx * 1301);
        }
        return tearTextureCache[idx];
      }
      // Pre-warm texture cache during idle time
      if ('requestIdleCallback' in window) {
        requestIdleCallback(() => { for (let i = 0; i < 6; i++) getTearTexture(i); }, { timeout: 5000 });
      } else {
        setTimeout(() => { for (let i = 0; i < 6; i++) getTearTexture(i); }, 3000);
      }
      let tearCounter = 0;

      function addEdgeGrain(parent: HTMLElement, yPct: number, side: 'top' | 'bottom') {
        tearCounter++;
        const tex1 = getTearTexture(tearCounter);
        const tex2 = getTearTexture(tearCounter + 100);

        // Gradient mask: texture is fully opaque at the tear line and
        // fades to transparent as it moves away into clean paper.
        // 'top' side = torn edge is at the bottom of this piece → fade upward
        // 'bottom' side = torn edge is at the top of this piece → fade downward
        const maskTop = side === 'top'
          ? 'linear-gradient(to top, rgba(0,0,0,1) 0%, rgba(0,0,0,0.6) 35%, rgba(0,0,0,0) 100%)'
          : 'linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,0.6) 35%, rgba(0,0,0,0) 100%)';

        // Layer 1: Main fiber texture — pronounced, multiply blend
        const grain = document.createElement('div');
        Object.assign(grain.style, {
          position: 'absolute',
          left: '-3px',
          right: '-3px',
          top: `${yPct}%`,
          height: '20px',
          transform: 'translateY(-50%)',
          backgroundImage: `url(${tex1})`,
          backgroundSize: `${_texW}px ${_texH}px`,
          backgroundRepeat: 'repeat-x',
          mixBlendMode: 'multiply',
          opacity: '0.6',
          pointerEvents: 'none',
          zIndex: '99',
          WebkitMaskImage: maskTop,
          maskImage: maskTop,
        });
        parent.appendChild(grain);

        // Skip extra blend-mode layers on mobile for GPU savings
        if (!desktopFinePointer) return;

        // Layer 2: Offset texture for depth — darken blend, shifted
        const depth = document.createElement('div');
        Object.assign(depth.style, {
          position: 'absolute',
          left: '-2px',
          right: '-2px',
          top: `${yPct}%`,
          height: '14px',
          transform: 'translateY(-50%) translateX(3px)',
          backgroundImage: `url(${tex2})`,
          backgroundSize: '350px 24px',
          backgroundRepeat: 'repeat-x',
          mixBlendMode: 'darken',
          opacity: '0.4',
          pointerEvents: 'none',
          zIndex: '100',
          WebkitMaskImage: maskTop,
          maskImage: maskTop,
        });
        parent.appendChild(depth);

        // Layer 3: Color-tinted edge line — theme-aware tint at tear
        const tearTint = getThemeColor('--color-tear-tint') || 'rgba(140,110,70,0.15)';
        const tint = document.createElement('div');
        Object.assign(tint.style, {
          position: 'absolute',
          left: '-1px',
          right: '-1px',
          top: `${yPct}%`,
          height: '3px',
          transform: 'translateY(-50%)',
          background: `linear-gradient(90deg, transparent, ${tearTint} 20%, ${tearTint} 50%, ${tearTint} 80%, transparent)`,
          pointerEvents: 'none',
          zIndex: '101',
        });
        parent.appendChild(tint);
      }

      function makePieceEl(polygon: Point[], edges: EdgeInfo[], offsetX: number, offsetY: number, rot: number): { el: HTMLElement; clipEl: HTMLElement; printables: HTMLElement[] } {
        const clone = receipt!.cloneNode(true) as HTMLElement;
        clone.removeAttribute('id');
        const p = { polygon, edges, offsetX, offsetY, rotation: rot, printables: [] } as TearPiece;

        // Inner element: clipped receipt content (pointer-events here so clip-path limits hit area)
        Object.assign(clone.style, {
          position: 'relative',
          width: '100%',
          margin: '0',
          visibility: 'visible',
          clipPath: clipFor(p),
          boxShadow: 'none',
          filter: PIECE_SHADOW,
          overflow: 'hidden',
          pointerEvents: handMode ? 'auto' : 'none',
        });

        // Add edge grain to torn edges (skip cut edges — they rely on piece drop-shadow)
        const centroidY = polygon.reduce((s, v) => s + v.y, 0) / polygon.length;
        for (let i = 0; i < edges.length; i++) {
          if (!edges[i].jagged || edges[i].source === 'cut') continue;
          const from = polygon[i];
          const to = polygon[(i + 1) % polygon.length];
          const edgeY = (from.y + to.y) / 2;
          const side = centroidY < edgeY ? 'top' : 'bottom';
          addEdgeGrain(clone, edgeY, side);
        }

        // Wrapper: positioned container, washi/seam traces go here (outside clip)
        const wrapper = document.createElement('div');
        wrapper.classList.add('receipt-piece');
        Object.assign(wrapper.style, {
          position: 'absolute',
          top: '0',
          left: '50%',
          width: receipt!.offsetWidth + 'px',
          transform: transformFor(p),
          transformOrigin: 'center center',
          backfaceVisibility: 'hidden',
          willChange: 'transform',
          pointerEvents: 'none',
          zIndex: '10',
          transition: 'none',
        });
        wrapper.appendChild(clone);

        const printables = Array.from(clone.querySelectorAll('[data-print]')) as HTMLElement[];
        return { el: wrapper, clipEl: clone, printables };
      }

      function seamClipPath(edge: JaggedEdge, basePct: number): string {
        const halfThicknessPx = 0.5;
        const topPoints: string[] = [];
        const bottomPoints: string[] = [];
        for (let i = 0; i < edge.length; i++) {
          const x = (i / (edge.length - 1)) * 100;
          const topY = basePct + ((edge[i] - halfThicknessPx) / receiptH) * 100;
          const bottomY = basePct + ((edge[i] + halfThicknessPx) / receiptH) * 100;
          topPoints.push(`${x.toFixed(2)}% ${topY.toFixed(2)}%`);
          bottomPoints.push(`${x.toFixed(2)}% ${bottomY.toFixed(2)}%`);
        }
        bottomPoints.reverse();
        return `polygon(${topPoints.join(', ')}, ${bottomPoints.join(', ')})`;
      }

      function addSeamTrace(parent: HTMLElement, edge: JaggedEdge, seamYPct: number) {
        const seam = document.createElement('div');
        seam.className = 'tape-seam';
        seam.dataset.seamY = seamYPct.toFixed(3);
        seam.style.clipPath = seamClipPath(edge, seamYPct);
        parent.appendChild(seam);
      }

      function addWashiStrip(parent: HTMLElement, stroke: TapeStroke, seamYPct: number, pieceAngleDeg: number) {
        const rr = receipt!.getBoundingClientRect();
        if (rr.width < 1 || rr.height < 1) return;

        const startXPct = ((stroke.startX - rr.left) / rr.width) * 100;
        const endXPct = ((stroke.endX - rr.left) / rr.width) * 100;
        const centerXPct = clampPct((startXPct + endXPct) / 2, -12, 112);
        const widthPct = clampPct(Math.abs(endXPct - startXPct) + 14, 22, 110);
        const rawAngle = Math.atan2(stroke.endY - stroke.startY, stroke.endX - stroke.startX) * (180 / Math.PI);
        const relativeAngle = rawAngle - pieceAngleDeg;

        const strip = document.createElement('div');
        strip.className = 'washi-strip';
        strip.dataset.seamY = seamYPct.toFixed(3);
        strip.style.left = `${centerXPct}%`;
        strip.style.top = `${seamYPct.toFixed(3)}%`;
        strip.style.width = `${widthPct.toFixed(3)}%`;
        strip.style.height = '20px';
        strip.style.transform = `translate(-50%, -50%) rotate(${relativeAngle.toFixed(3)}deg)`;
        strip.style.clipPath = createWashiClipPath();
        strip.style.setProperty('--washi-alpha', (0.80 + Math.random() * 0.12).toFixed(2));
        parent.appendChild(strip);
      }

      function addFreeWashiStrip(stroke: TapeStroke) {
        const dx = stroke.endX - stroke.startX;
        const dy = stroke.endY - stroke.startY;
        const len = Math.hypot(dx, dy);
        if (len < 2) return;

        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        const overlayRect = washiOverlay.getBoundingClientRect();
        const midX = (stroke.startX + stroke.endX) / 2 - overlayRect.left;
        const midY = (stroke.startY + stroke.endY) / 2 - overlayRect.top;
        if (!Number.isFinite(midX) || !Number.isFinite(midY)) return;

        const strip = document.createElement('div');
        strip.className = 'washi-strip';
        strip.style.left = `${midX.toFixed(2)}px`;
        strip.style.top = `${midY.toFixed(2)}px`;
        strip.style.width = `${(len + 12).toFixed(2)}px`;
        strip.style.height = '20px';
        strip.style.transform = `translate(-50%, -50%) rotate(${angle.toFixed(3)}deg)`;
        strip.style.clipPath = createWashiClipPath();
        strip.style.setProperty('--washi-alpha', (0.80 + Math.random() * 0.12).toFixed(2));
        washiOverlay.appendChild(strip);
      }

      function pointToSegmentDistance(
        px: number,
        py: number,
        x1: number,
        y1: number,
        x2: number,
        y2: number,
      ): number {
        const vx = x2 - x1;
        const vy = y2 - y1;
        const wx = px - x1;
        const wy = py - y1;
        const c1 = vx * wx + vy * wy;
        if (c1 <= 0) return Math.hypot(px - x1, py - y1);
        const c2 = vx * vx + vy * vy;
        if (c2 <= c1) return Math.hypot(px - x2, py - y2);
        const b = c1 / c2;
        const bx = x1 + b * vx;
        const by = y1 + b * vy;
        return Math.hypot(px - bx, py - by);
      }

      function strokeCrossesHorizontalSeam(
        stroke: TapeStroke,
        seamY: number,
        seamLeft: number,
        seamRight: number,
      ): boolean {
        const y1 = stroke.startY;
        const y2 = stroke.endY;
        const x1 = stroke.startX;
        const x2 = stroke.endX;
        const dy = y2 - y1;
        if (Math.abs(dy) < 0.001) return false;
        const t = (seamY - y1) / dy;
        if (t < 0 || t > 1) return false;
        const xAtSeam = x1 + (x2 - x1) * t;
        return xAtSeam >= seamLeft - 26 && xAtSeam <= seamRight + 26;
      }

      function strokeIntersectsSeamBand(
        stroke: TapeStroke,
        seamY: number,
        seamLeft: number,
        seamRight: number,
      ): boolean {
        const sxMin = Math.min(stroke.startX, stroke.endX);
        const sxMax = Math.max(stroke.startX, stroke.endX);
        const syMin = Math.min(stroke.startY, stroke.endY);
        const syMax = Math.max(stroke.startY, stroke.endY);
        const bandPadX = 34;
        const bandPadY = 34;

        const overlapsBandBox =
          sxMax >= seamLeft - bandPadX &&
          sxMin <= seamRight + bandPadX &&
          syMax >= seamY - bandPadY &&
          syMin <= seamY + bandPadY;
        if (!overlapsBandBox) return false;

        if (strokeCrossesHorizontalSeam(stroke, seamY, seamLeft, seamRight)) return true;

        const midX = (stroke.startX + stroke.endX) / 2;
        const midY = (stroke.startY + stroke.endY) / 2;
        const nearX = midX >= seamLeft - bandPadX && midX <= seamRight + bandPadX;
        const nearY = Math.abs(midY - seamY) <= bandPadY;
        return nearX && nearY;
      }

      function getSeamGeometry(topPiece: TearPiece, bottomPiece: TearPiece) {
        const rr = receipt!.getBoundingClientRect();
        const rh = rr.height;
        const parentRect = receipt!.parentElement!.getBoundingClientRect();
        const baseCX = parentRect.left + parentRect.width / 2;
        const halfW = receipt!.offsetWidth / 2;

        const topVisibleBottom = rr.top + (polyBottom(topPiece) / 100) * rh + topPiece.offsetY;
        const bottomVisibleTop = rr.top + (polyTop(bottomPiece) / 100) * rh + bottomPiece.offsetY;

        // Use actual piece positions for horizontal bounds (overlap of the two pieces)
        const topLeft = baseCX + topPiece.offsetX - halfW;
        const topRight = baseCX + topPiece.offsetX + halfW;
        const bottomLeft = baseCX + bottomPiece.offsetX - halfW;
        const bottomRight = baseCX + bottomPiece.offsetX + halfW;

        return {
          seamY: (topVisibleBottom + bottomVisibleTop) / 2,
          seamGap: Math.abs(bottomVisibleTop - topVisibleBottom),
          seamLeft: Math.max(topLeft, bottomLeft) - 20,
          seamRight: Math.min(topRight, bottomRight) + 20,
        };
      }

      function findSeamIndexForStroke(stroke: TapeStroke): number {
        if (!tearSystemReady || pieces.length < 2) return -1;
        const dx = stroke.endX - stroke.startX;
        const dy = stroke.endY - stroke.startY;
        const length = Math.hypot(dx, dy);
        if (length < 10) return -1;
        const midX = (stroke.startX + stroke.endX) / 2;
        const midY = (stroke.startY + stroke.endY) / 2;

        let bestIdx = -1;
        let bestScore = Infinity;
        for (let i = 0; i < pieces.length - 1; i++) {
          const topPiece = pieces[i];
          const bottomPiece = pieces[i + 1];

          const { seamY, seamGap, seamLeft, seamRight } = getSeamGeometry(topPiece, bottomPiece);
          if (seamRight <= seamLeft) continue; // no horizontal overlap
          if (seamGap > 200) continue; // pieces too far apart vertically
          if (!strokeIntersectsSeamBand(stroke, seamY, seamLeft, seamRight)) continue;

          const probeX = clampPct(midX, seamLeft, seamRight);
          const distMid = pointToSegmentDistance(
            probeX,
            seamY,
            stroke.startX,
            stroke.startY,
            stroke.endX,
            stroke.endY,
          );
          const distLeft = pointToSegmentDistance(
            seamLeft,
            seamY,
            stroke.startX,
            stroke.startY,
            stroke.endX,
            stroke.endY,
          );
          const distRight = pointToSegmentDistance(
            seamRight,
            seamY,
            stroke.startX,
            stroke.startY,
            stroke.endX,
            stroke.endY,
          );
          const distToStroke = Math.min(distMid, distLeft, distRight);
          const seamOffsetPenalty = Math.abs(midY - seamY) * 0.35;
          const verticalBonus = Math.abs(dy) > Math.abs(dx) * 0.85 ? -10 : 0;
          const score = distToStroke + seamOffsetPenalty + verticalBonus;
          if (score < bestScore) {
            bestScore = score;
            bestIdx = i;
          }
        }
        if (bestScore > 140) return -1;
        return bestIdx;
      }

      function findNearestSeamByMidpoint(stroke: TapeStroke): number {
        if (!tearSystemReady || pieces.length < 2) return -1;
        const midY = (stroke.startY + stroke.endY) / 2;

        let bestIdx = -1;
        let bestDist = Infinity;
        for (let i = 0; i < pieces.length - 1; i++) {
          const { seamY, seamGap, seamLeft, seamRight } = getSeamGeometry(pieces[i], pieces[i + 1]);
          if (seamRight <= seamLeft) continue; // no horizontal overlap
          if (seamGap > 200) continue; // pieces too far apart
          const dist = Math.abs(midY - seamY);
          if (dist < bestDist) {
            bestDist = dist;
            bestIdx = i;
          }
        }
        if (bestDist > 110) return -1;
        return bestIdx;
      }

      function mergePiecesAt(topIdx: number, stroke: TapeStroke | null): boolean {
        if (topIdx < 0 || topIdx >= pieces.length - 1) return false;

        const topPiece = pieces[topIdx];
        const bottomPiece = pieces[topIdx + 1];

        // Find the shared seam edge: look for a jagged edge at the boundary
        // For horizontal tears, this is the bottom edge of topPiece or top edge of bottomPiece
        let seamEdge: JaggedEdge | null = null;
        for (let i = 0; i < topPiece.edges.length; i++) {
          if (topPiece.edges[i].jagged) {
            const from = topPiece.polygon[i];
            const to = topPiece.polygon[(i + 1) % topPiece.polygon.length];
            if (Math.abs(from.y - polyBottom(topPiece)) < 0.1 && Math.abs(to.y - polyBottom(topPiece)) < 0.1) {
              seamEdge = topPiece.edges[i].jagged;
              break;
            }
          }
        }
        if (!seamEdge) {
          for (let i = 0; i < bottomPiece.edges.length; i++) {
            if (bottomPiece.edges[i].jagged) {
              const from = bottomPiece.polygon[i];
              const to = bottomPiece.polygon[(i + 1) % bottomPiece.polygon.length];
              if (Math.abs(from.y - polyTop(bottomPiece)) < 0.1 && Math.abs(to.y - polyTop(bottomPiece)) < 0.1) {
                seamEdge = bottomPiece.edges[i].jagged;
                break;
              }
            }
          }
        }
        if (!seamEdge) seamEdge = generateJaggedEdge();

        const wrapper = receipt!.parentElement!;
        const seamYPct = (polyBottom(topPiece) + polyTop(bottomPiece)) / 2;
        const mergedOffsetX = (topPiece.offsetX + bottomPiece.offsetX) / 2;
        const mergedOffsetY = topPiece.offsetY;
        const mergedRotation = (topPiece.rotation + bottomPiece.rotation) / 2;

        // Build merged polygon: take the outer boundary of the top piece (excluding tear edge)
        // and the outer boundary of the bottom piece (excluding tear edge), joined at the seam.
        // For horizontal tears this creates a rectangle from topPiece's top to bottomPiece's bottom.
        const mergedPoly: Point[] = [
          { x: 0, y: polyTop(topPiece) },
          { x: 100, y: polyTop(topPiece) },
          { x: 100, y: polyBottom(bottomPiece) },
          { x: 0, y: polyBottom(bottomPiece) },
        ];

        // Find the top and bottom outer edges' jagged info from the original pieces
        let mergedTopJagged: JaggedEdge | null = null;
        let mergedBotJagged: JaggedEdge | null = null;
        // Top edge of topPiece (the one going left-to-right at polyTop)
        for (let i = 0; i < topPiece.edges.length; i++) {
          const from = topPiece.polygon[i];
          const to = topPiece.polygon[(i + 1) % topPiece.polygon.length];
          if (Math.abs(from.y - polyTop(topPiece)) < 0.1 && Math.abs(to.y - polyTop(topPiece)) < 0.1 && from.x < to.x) {
            mergedTopJagged = topPiece.edges[i].jagged;
            break;
          }
        }
        // Bottom edge of bottomPiece (the one going right-to-left at polyBottom)
        for (let i = 0; i < bottomPiece.edges.length; i++) {
          const from = bottomPiece.polygon[i];
          const to = bottomPiece.polygon[(i + 1) % bottomPiece.polygon.length];
          if (Math.abs(from.y - polyBottom(bottomPiece)) < 0.1 && Math.abs(to.y - polyBottom(bottomPiece)) < 0.1 && from.x > to.x) {
            mergedBotJagged = bottomPiece.edges[i].jagged;
            break;
          }
        }

        const mergedEdges: EdgeInfo[] = [
          { jagged: mergedTopJagged },  // top edge left→right
          { jagged: null },              // right side
          { jagged: mergedBotJagged },  // bottom edge right→left
          { jagged: null },              // left side
        ];

        const { el: mergedEl, clipEl: mergedClipEl, printables: mergedPrintables } = makePieceEl(
          mergedPoly,
          mergedEdges,
          mergedOffsetX,
          mergedOffsetY,
          mergedRotation,
        );
        const nextEl = pieces[topIdx + 2]?.el;
        if (nextEl) wrapper.insertBefore(mergedEl, nextEl);
        else wrapper.appendChild(mergedEl);

        if (stroke) addWashiStrip(mergedEl, stroke, seamYPct, baseRotation + mergedRotation);
        addSeamTrace(mergedEl, seamEdge, seamYPct);

        // Transfer existing seam traces and washi strips from old pieces to merged element
        for (const child of [...topPiece.el.querySelectorAll(':scope > .tape-seam, :scope > .washi-strip')]) {
          mergedEl.appendChild(child);
        }
        for (const child of [...bottomPiece.el.querySelectorAll(':scope > .tape-seam, :scope > .washi-strip')]) {
          mergedEl.appendChild(child);
        }

        topPiece.el.remove();
        bottomPiece.el.remove();

        const mergedPiece: TearPiece = {
          el: mergedEl,
          clipEl: mergedClipEl,
          polygon: mergedPoly,
          edges: mergedEdges,
          offsetX: mergedOffsetX,
          offsetY: mergedOffsetY,
          rotation: mergedRotation,
          printables: mergedPrintables,
        };

        pieces.splice(topIdx, 2, mergedPiece);

        animatePiece(mergedPiece);

        const maxOff = pieces.length > 0 ? Math.max(...pieces.map(p => p.offsetY)) : 0;
        wrapper.style.paddingBottom = `${maxOff + 40}px`;
        return true;
      }

      // Animate a piece to its current state with a spring curve
      function animatePiece(
        p: TearPiece,
        transition: string = 'transform 0.55s cubic-bezier(0.34, 1.56, 0.64, 1)',
      ) {
        p.el.style.transition = transition;
        p.clipEl.style.clipPath = clipFor(p);
        p.el.style.transform = transformFor(p);
        p.el.style.opacity = '1';
      }

      // ---- Freehand cut: path simplification + polygon splitting ----

      function pointInPolygon(pt: Point, poly: Point[]): boolean {
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
          const yi = poly[i].y, yj = poly[j].y;
          const xi = poly[i].x, xj = poly[j].x;
          if ((yi > pt.y) !== (yj > pt.y) && pt.x < (xj - xi) * (pt.y - yi) / (yj - yi) + xi) {
            inside = !inside;
          }
        }
        return inside;
      }

      function nearestEdgeProjection(pt: Point, poly: Point[]): { edgeIdx: number; pt: Point } {
        let bestDist = Infinity;
        let bestProj = { edgeIdx: 0, pt: { ...poly[0] } };
        for (let i = 0; i < poly.length; i++) {
          const a = poly[i], b = poly[(i + 1) % poly.length];
          const dx = b.x - a.x, dy = b.y - a.y;
          const lenSq = dx * dx + dy * dy;
          const t = lenSq > 0 ? Math.max(0, Math.min(1, ((pt.x - a.x) * dx + (pt.y - a.y) * dy) / lenSq)) : 0;
          const proj = { x: a.x + dx * t, y: a.y + dy * t };
          const dist = Math.hypot(pt.x - proj.x, pt.y - proj.y);
          if (dist < bestDist) {
            bestDist = dist;
            bestProj = { edgeIdx: i, pt: proj };
          }
        }
        return bestProj;
      }

      function simplifyPath(pts: { x: number; y: number }[], tolerance: number): { x: number; y: number }[] {
        if (pts.length <= 2) return pts;
        let maxDist = 0;
        let maxIdx = 0;
        const first = pts[0];
        const last = pts[pts.length - 1];
        for (let i = 1; i < pts.length - 1; i++) {
          const d = pointToLineDist(pts[i], first, last);
          if (d > maxDist) { maxDist = d; maxIdx = i; }
        }
        if (maxDist > tolerance) {
          const left = simplifyPath(pts.slice(0, maxIdx + 1), tolerance);
          const right = simplifyPath(pts.slice(maxIdx), tolerance);
          return [...left.slice(0, -1), ...right];
        }
        return [first, last];
      }

      function pointToLineDist(p: { x: number; y: number }, a: { x: number; y: number }, b: { x: number; y: number }): number {
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const lenSq = dx * dx + dy * dy;
        if (lenSq === 0) return Math.hypot(p.x - a.x, p.y - a.y);
        return Math.abs(dx * (a.y - p.y) - dy * (a.x - p.x)) / Math.sqrt(lenSq);
      }

      function segSegIntersect(
        a1: Point, a2: Point, b1: Point, b2: Point
      ): { t: number; u: number; pt: Point } | null {
        const d1x = a2.x - a1.x, d1y = a2.y - a1.y;
        const d2x = b2.x - b1.x, d2y = b2.y - b1.y;
        const denom = d1x * d2y - d1y * d2x;
        if (Math.abs(denom) < 1e-10) return null;
        const t = ((b1.x - a1.x) * d2y - (b1.y - a1.y) * d2x) / denom;
        const u = ((b1.x - a1.x) * d1y - (b1.y - a1.y) * d1x) / denom;
        if (t < 0 || t > 1 || u < 0 || u > 1) return null;
        return { t, u, pt: { x: a1.x + d1x * t, y: a1.y + d1y * t } };
      }

      function polygonArea(poly: Point[]): number {
        let area = 0;
        for (let i = 0; i < poly.length; i++) {
          const j = (i + 1) % poly.length;
          area += poly[i].x * poly[j].y - poly[j].x * poly[i].y;
        }
        return Math.abs(area) / 2;
      }

      function executeCutAll(screenPoints: { x: number; y: number }[]) {
        cutGeneration++;
        // Capture piece offsets at stroke time so coordinate mapping stays consistent
        // even after cuts shift pieces down with TEAR_GAP
        const baseOffsets = new Map<TearPiece, number>();
        for (const p of pieces) baseOffsets.set(p, p.offsetY);
        const consumedRanges: [number, number][] = [];
        for (let pass = 0; pass < 8; pass++) {
          const range = executeCut(screenPoints, baseOffsets, consumedRanges);
          if (!range) break;
          consumedRanges.push(range);
        }
      }

      function executeCut(screenPoints: { x: number; y: number }[], baseOffsets?: Map<TearPiece, number>, consumedRanges?: [number, number][]): [number, number] | null {
        initTearSystem();
        if (pieces.length === 0) return null;

        const rr = receipt!.getBoundingClientRect();
        const rh = rr.height;
        const rw = rr.width;

        // Convert screen coords to receipt percentage coords
        const pctPoints: Point[] = screenPoints.map(sp => ({
          x: ((sp.x - rr.left) / rw) * 100,
          y: ((sp.y - rr.top) / rh) * 100,
        }));

        // Simplify (tolerance in percentage units, ~2px equivalent)
        const tolerance = (2 / rw) * 100;
        const simplified = simplifyPath(pctPoints, tolerance);
        if (simplified.length < 2) return null;

        // Find which piece the cut path intersects most (by number of intersections)
        let bestPiece: TearPiece | null = null;
        let bestIdx = -1;
        let bestEntry: { polySegIdx: number; cutSegIdx: number; t: number; pt: Point } | null = null;
        let bestExit: { polySegIdx: number; cutSegIdx: number; t: number; pt: Point } | null = null;

        for (let pi = 0; pi < pieces.length; pi++) {
          const p = pieces[pi];
          // Adjust polyline for piece offset (use base offset from stroke time for consistency)
          const baseOff = baseOffsets?.get(p) ?? p.offsetY;
          const adjustedSimp = simplified.map(pt => ({
            x: pt.x,
            y: pt.y - (baseOff / rh) * 100,
          }));

          const crossings: { polySegIdx: number; cutSegIdx: number; t: number; pt: Point }[] = [];

          // Find all intersections between the cut polyline and polygon edges
          for (let ci = 0; ci < adjustedSimp.length - 1; ci++) {
            const c1 = adjustedSimp[ci];
            const c2 = adjustedSimp[ci + 1];
            for (let ei = 0; ei < p.polygon.length; ei++) {
              if (p.edges[ei]?.source === 'cut' && p.edges[ei]?.cutGen === cutGeneration) continue;
              const e1 = p.polygon[ei];
              const e2 = p.polygon[(ei + 1) % p.polygon.length];
              const hit = segSegIntersect(c1, c2, e1, e2);
              if (hit) {
                crossings.push({ polySegIdx: ei, cutSegIdx: ci, t: hit.t, pt: hit.pt });
              }
            }
          }

          if (crossings.length >= 2) {
            // Sort crossings by position along the cut polyline
            crossings.sort((a, b) => a.cutSegIdx - b.cutSegIdx || a.t - b.t);
            // Find the first consecutive crossing pair where the path between them
            // is inside the polygon (confirmed entry→exit, not exit→entry).
            // This handles concave polygons from prior cuts where blind ci+=2 pairing fails.
            const z = parseInt(p.el.style.zIndex) || 0;
            let pairEntry: typeof crossings[0] | null = null;
            let pairExit: typeof crossings[0] | null = null;
            for (let ci = 0; ci < crossings.length - 1; ci++) {
              const c1 = crossings[ci];
              const c2 = crossings[ci + 1];
              if (c1.polySegIdx === c2.polySegIdx) continue;
              // Skip pairs that overlap with already-consumed cut ranges
              const pairLo = Math.min(c1.cutSegIdx, c2.cutSegIdx);
              const pairHi = Math.max(c1.cutSegIdx, c2.cutSegIdx);
              if (consumedRanges?.some(([lo, hi]) => pairLo < hi && pairHi > lo)) continue;
              // Verify the path between these crossings is inside the polygon
              const midIdx = Math.min(
                c1.cutSegIdx + Math.max(1, Math.floor((c2.cutSegIdx - c1.cutSegIdx) / 2)),
                adjustedSimp.length - 1
              );
              if (!pointInPolygon(adjustedSimp[midIdx], p.polygon)) continue;
              pairEntry = c1;
              pairExit = c2;
              break;
            }
            if (pairEntry && pairExit) {
              if (!bestPiece || z > (parseInt(bestPiece.el.style.zIndex) || 0)) {
                bestPiece = p;
                bestIdx = pi;
                bestEntry = pairEntry;
                bestExit = pairExit;
              }
            }
          } else if (crossings.length === 1) {
            // Forgiveness: cut starts or ends inside the polygon
            const crossing = crossings[0];
            const startPt = adjustedSimp[0];
            const endPt = adjustedSimp[adjustedSimp.length - 1];
            const startInside = pointInPolygon(startPt, p.polygon);
            const endInside = pointInPolygon(endPt, p.polygon);

            let entry: typeof crossing | null = null;
            let exit: typeof crossing | null = null;

            if (startInside) {
              const proj = nearestEdgeProjection(startPt, p.polygon);
              entry = { polySegIdx: proj.edgeIdx, cutSegIdx: 0, t: 0, pt: proj.pt };
              exit = crossing;
            } else if (endInside) {
              entry = crossing;
              const proj = nearestEdgeProjection(endPt, p.polygon);
              exit = { polySegIdx: proj.edgeIdx, cutSegIdx: adjustedSimp.length - 2, t: 1, pt: proj.pt };
            }

            if (entry && exit && entry.polySegIdx !== exit.polySegIdx) {
              const z = parseInt(p.el.style.zIndex) || 0;
              if (!bestPiece || z > (parseInt(bestPiece.el.style.zIndex) || 0)) {
                bestPiece = p;
                bestIdx = pi;
                bestEntry = entry;
                bestExit = exit;
              }
            }
          } else if (crossings.length === 0) {
            const startPt = adjustedSimp[0];
            const endPt = adjustedSimp[adjustedSimp.length - 1];
            if (pointInPolygon(startPt, p.polygon) && pointInPolygon(endPt, p.polygon)) {
              const projStart = nearestEdgeProjection(startPt, p.polygon);
              const projEnd = nearestEdgeProjection(endPt, p.polygon);
              if (projStart.edgeIdx !== projEnd.edgeIdx) {
                const maxDistPct = desktopFinePointer ? 5 : 10;
                const distStart = Math.hypot(startPt.x - projStart.pt.x, startPt.y - projStart.pt.y);
                const distEnd = Math.hypot(endPt.x - projEnd.pt.x, endPt.y - projEnd.pt.y);
                if (distStart <= maxDistPct && distEnd <= maxDistPct) {
                  const entry = { polySegIdx: projStart.edgeIdx, cutSegIdx: 0, t: 0, pt: projStart.pt };
                  const exit = { polySegIdx: projEnd.edgeIdx, cutSegIdx: adjustedSimp.length - 2, t: 1, pt: projEnd.pt };
                  const z = parseInt(p.el.style.zIndex) || 0;
                  if (!bestPiece || z > (parseInt(bestPiece.el.style.zIndex) || 0)) {
                    bestPiece = p;
                    bestIdx = pi;
                    bestEntry = entry;
                    bestExit = exit;
                  }
                }
              }
            }
          }
        }

        if (!bestPiece || !bestEntry || !bestExit) return null;

        const target = bestPiece;
        const targetIdx = bestIdx;

        // Adjust simplified polyline to piece offset coordinates (use base offset)
        const targetBaseOff = baseOffsets?.get(target) ?? target.offsetY;
        const adjustedCut = simplified.map(pt => ({
          x: pt.x,
          y: pt.y - (targetBaseOff / rh) * 100,
        }));

        // Build the cut path between entry and exit points (in piece-local pct coords)
        const cutPath: Point[] = [bestEntry.pt];
        // Add intermediate points from the simplified polyline between entry and exit
        for (let ci = bestEntry.cutSegIdx + 1; ci <= bestExit.cutSegIdx; ci++) {
          cutPath.push(adjustedCut[ci]);
        }
        cutPath.push(bestExit.pt);

        // Split the polygon into two pieces along the cut path
        const entryEdge = bestEntry.polySegIdx;
        const exitEdge = bestExit.polySegIdx;
        const n = target.polygon.length;

        // Generate jagged edges for each cut segment (shared by both child pieces)
        const cutJagged: JaggedEdge[] = [];
        const cutJaggedReversed: JaggedEdge[] = [];
        for (let i = 0; i < cutPath.length - 1; i++) {
          const edge = generateJaggedEdge();
          cutJagged.push(edge);
          cutJaggedReversed.push([...edge].reverse());
        }

        // Piece A: entry → cut path forward → exit → walk polygon edges back to entry
        const polyA: Point[] = [];
        const edgesA: EdgeInfo[] = [];

        // Start with the cut path
        for (const pt of cutPath) polyA.push(pt);
        for (let i = 0; i < cutPath.length - 1; i++) edgesA.push({ jagged: cutJagged[i], source: 'cut', cutGen: cutGeneration });

        // Edge from exit point to first polygon vertex (partial of exitEdge)
        edgesA.push(target.edges[exitEdge]);

        // Walk polygon vertices from (exitEdge+1) through entryEdge
        let walkIdx = (exitEdge + 1) % n;
        const stopIdx = (entryEdge + 1) % n;
        let safety = 0;
        while (walkIdx !== stopIdx && safety < n + 1) {
          polyA.push(target.polygon[walkIdx]);
          edgesA.push(target.edges[walkIdx]);
          walkIdx = (walkIdx + 1) % n;
          safety++;
        }

        // Piece B: exit → cut path reversed → entry → walk polygon edges back to exit
        const polyB: Point[] = [];
        const edgesB: EdgeInfo[] = [];

        // Reversed cut path — segment i in B = segment (numSegs-1-i) of the original, reversed
        for (let i = cutPath.length - 1; i >= 0; i--) polyB.push(cutPath[i]);
        const numSegs = cutPath.length - 1;
        for (let i = 0; i < numSegs; i++) edgesB.push({ jagged: cutJaggedReversed[numSegs - 1 - i], source: 'cut', cutGen: cutGeneration });

        // Edge from entry point to first polygon vertex (partial of entryEdge)
        edgesB.push(target.edges[entryEdge]);

        // Walk polygon vertices from (entryEdge+1) through exitEdge
        walkIdx = (entryEdge + 1) % n;
        const stopIdxB = (exitEdge + 1) % n;
        safety = 0;
        while (walkIdx !== stopIdxB && safety < n + 1) {
          polyB.push(target.polygon[walkIdx]);
          edgesB.push(target.edges[walkIdx]);
          walkIdx = (walkIdx + 1) % n;
          safety++;
        }

        // Validate: skip if either piece is too small
        const MIN_AREA = 50; // percentage units squared
        if (polygonArea(polyA) < MIN_AREA || polygonArea(polyB) < MIN_AREA) return null;

        sounds.tearSound();
        dismissCutHint();

        // Determine which piece is "upper" (lower centroid Y) vs "lower"
        const centroidY = (poly: Point[]) => poly.reduce((s, p) => s + p.y, 0) / poly.length;
        const aY = centroidY(polyA);
        const bY = centroidY(polyB);

        // Assign: piece with lower centroid stays, other shifts down
        const upperPoly = aY <= bY ? polyA : polyB;
        const upperEdges = aY <= bY ? edgesA : edgesB;
        const lowerPoly = aY <= bY ? polyB : polyA;
        const lowerEdges = aY <= bY ? edgesB : edgesA;

        // Update target piece to be the upper portion
        target.polygon = upperPoly;
        target.edges = upperEdges;
        target.rotation += (Math.random() - 0.5) * 0.6;
        animatePiece(target);

        // Create new piece for lower portion
        const wrapper = receipt!.parentElement!;
        const { el: newEl, clipEl: newClipEl, printables: newPrintables } = makePieceEl(
          lowerPoly, lowerEdges, target.offsetX, target.offsetY, target.rotation
        );
        wrapper.appendChild(newEl);

        const newPiece: TearPiece = {
          el: newEl,
          clipEl: newClipEl,
          polygon: lowerPoly,
          edges: lowerEdges,
          offsetX: target.offsetX,
          offsetY: target.offsetY,
          rotation: target.rotation,
          printables: newPrintables,
        };
        pieces.splice(targetIdx + 1, 0, newPiece);

        // Register new piece with parent's base offset for multi-cut coordinate consistency
        if (baseOffsets) baseOffsets.set(newPiece, baseOffsets.get(target) ?? target.offsetY);

        // Shift lower pieces down
        for (let i = targetIdx + 1; i < pieces.length; i++) {
          pieces[i].offsetY += TEAR_GAP;
          pieces[i].rotation += (Math.random() - 0.5) * 1.2;
        }

        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            for (let i = targetIdx + 1; i < pieces.length; i++) {
              animatePiece(pieces[i]);
            }
          });
        });

        const maxOff = pieces[pieces.length - 1].offsetY;
        wrapper.style.paddingBottom = (maxOff + 40) + 'px';

        invalidateLayoutCache();
        return [bestEntry!.cutSegIdx, bestExit!.cutSegIdx] as [number, number];
      }

      function executeTear(swipeX: number, swipeY: number): boolean {
        initTearSystem();

        const rr = receipt!.getBoundingClientRect();
        const rh = rr.height;

        // Find which piece the swipe falls within — pick the topmost (highest z-index)
        let candidates: { piece: TearPiece; idx: number; pct: number }[] = [];

        for (let i = 0; i < pieces.length; i++) {
          const p = pieces[i];
          const pieceRect = p.el.getBoundingClientRect();

          // Check horizontal overlap (skip pieces that aren't under the swipe X)
          if (swipeX < pieceRect.left - CUT_EDGE_PADDING || swipeX > pieceRect.right + CUT_EDGE_PADDING) continue;

          // Use manual Y calculation for precise tear percentage (bounding rect is affected by rotation)
          const pTop = polyTop(p);
          const pBot = polyBottom(p);
          const vTop = rr.top + (pTop / 100) * rh + p.offsetY;
          const vBot = rr.top + (pBot / 100) * rh + p.offsetY;
          const safeTop = vTop + CUT_EDGE_SAFETY;
          const safeBot = vBot - CUT_EDGE_SAFETY;
          if (swipeY >= safeTop - CUT_EDGE_PADDING && swipeY <= safeBot + CUT_EDGE_PADDING) {
            const clampedY = Math.max(safeTop, Math.min(safeBot, swipeY));
            const pct = ((clampedY - rr.top - p.offsetY) / rh) * 100;
            candidates.push({ piece: p, idx: i, pct });
          }
        }

        if (candidates.length === 0) return false;

        // Pick the visually topmost piece (highest z-index)
        if (candidates.length > 1) {
          candidates.sort((a, b) => (parseInt(b.piece.el.style.zIndex) || 0) - (parseInt(a.piece.el.style.zIndex) || 0));
        }
        const target = candidates[0].piece;
        const targetIdx = candidates[0].idx;
        const tearPct = candidates[0].pct;

        sounds.tearSound();
        dismissCutHint();

        // Generate shared jagged edge for this tear (both pieces share it)
        const jaggedEdge = generateJaggedEdge();
        // Reversed copy for the bottom edge of the top piece (polygon walks right-to-left there)
        const jaggedEdgeReversed = [...jaggedEdge].reverse();

        // Split target polygon horizontally at tearPct.
        // Current polygon is a rectangle-like shape; find which edges cross y=tearPct.
        // For a horizontal tear, the top piece gets the upper portion, bottom piece the lower.
        const topPoly: Point[] = [];
        const topEdges: EdgeInfo[] = [];
        const botPoly: Point[] = [];
        const botEdges: EdgeInfo[] = [];

        // Walk the polygon and split edges that cross tearPct
        const n = target.polygon.length;
        for (let i = 0; i < n; i++) {
          const curr = target.polygon[i];
          const next = target.polygon[(i + 1) % n];
          const currAbove = curr.y <= tearPct;
          const nextAbove = next.y <= tearPct;

          if (currAbove) {
            topPoly.push(curr);
          } else {
            botPoly.push(curr);
          }

          // Edge crosses the tear line — split it, pushing edge info to both halves
          if (currAbove !== nextAbove) {
            const t = (tearPct - curr.y) / (next.y - curr.y);
            const ix = curr.x + (next.x - curr.x) * t;
            const crossPt: Point = { x: ix, y: tearPct };

            if (currAbove) {
              // Going from above to below
              topPoly.push(crossPt);
              topEdges.push(target.edges[i]); // upper half: curr → crossPt
              botPoly.push({ ...crossPt });
              botEdges.push(target.edges[i]); // lower half: crossPt → next
            } else {
              // Going from below to above
              botPoly.push(crossPt);
              botEdges.push(target.edges[i]); // lower half: curr → crossPt
              topPoly.push({ ...crossPt });
              topEdges.push(target.edges[i]); // upper half: crossPt → next
            }
          } else {
            // Both vertices on the same side — edge stays with that side
            if (currAbove) {
              topEdges.push(target.edges[i]);
            } else {
              botEdges.push(target.edges[i]);
            }
          }
        }

        // Now add the tear edges connecting the crossing points.
        // For a horizontal rectangle, topPoly should have its last two points at y=tearPct,
        // connected by the jagged tear edge going right-to-left (clockwise for top piece).
        // botPoly should have its first two points at y=tearPct, connected going left-to-right.

        // Find the tear edge indices: in the top polygon, the last edge connects the two tear-line points
        // We need to insert jagged edges between the crossing points.
        // The top piece's bottom edge (the tear) goes right-to-left in clockwise order.
        // The bottom piece's top edge (the tear) goes left-to-right.

        // Determine which edges in top/botPoly are the tear edges
        // In topPoly: find the edge where both endpoints have y ≈ tearPct
        for (let i = 0; i < topPoly.length; i++) {
          const curr = topPoly[i];
          const next = topPoly[(i + 1) % topPoly.length];
          if (Math.abs(curr.y - tearPct) < 0.01 && Math.abs(next.y - tearPct) < 0.01) {
            // This is the tear edge — determine direction for jagged data
            const goesRightToLeft = curr.x > next.x;
            topEdges.splice(i, 0, { jagged: goesRightToLeft ? jaggedEdgeReversed : jaggedEdge });
            break;
          }
        }
        for (let i = 0; i < botPoly.length; i++) {
          const curr = botPoly[i];
          const next = botPoly[(i + 1) % botPoly.length];
          if (Math.abs(curr.y - tearPct) < 0.01 && Math.abs(next.y - tearPct) < 0.01) {
            const goesLeftToRight = curr.x < next.x;
            botEdges.splice(i, 0, { jagged: goesLeftToRight ? jaggedEdge : jaggedEdgeReversed });
            break;
          }
        }

        // Update target piece to be the top portion
        target.polygon = topPoly;
        target.edges = topEdges;
        target.rotation += (Math.random() - 0.5) * 0.6;

        animatePiece(target);

        // Add grain after animatePiece (Safari blend-mode repaint issue)
        addEdgeGrain(target.clipEl, tearPct, 'top');

        // Create new piece for bottom portion
        const wrapper = receipt!.parentElement!;
        const { el: newEl, clipEl: newClipEl, printables: newPrintables } = makePieceEl(botPoly, botEdges, target.offsetX, target.offsetY, target.rotation);
        wrapper.appendChild(newEl);

        // Transfer seam traces and washi strips that fall below the tear to the new piece
        for (const child of [...target.el.querySelectorAll(':scope > .tape-seam, :scope > .washi-strip')]) {
          const yPct = parseFloat(child.getAttribute('data-seam-y') || '0');
          if (yPct >= tearPct) {
            newEl.appendChild(child);
          }
        }

        const newPiece: TearPiece = {
          el: newEl,
          clipEl: newClipEl,
          polygon: botPoly,
          edges: botEdges,
          offsetX: target.offsetX,
          offsetY: target.offsetY,
          rotation: target.rotation,
          printables: newPrintables,
        };
        pieces.splice(targetIdx + 1, 0, newPiece);

        // Prepare shift offsets synchronously (data only, no DOM writes)
        for (let i = targetIdx + 1; i < pieces.length; i++) {
          pieces[i].offsetY += TEAR_GAP;
          pieces[i].rotation += (Math.random() - 0.5) * 1.2;
        }

        // Use double-rAF to let browser paint initial state, then animate
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            for (let i = targetIdx + 1; i < pieces.length; i++) {
              animatePiece(pieces[i]);
            }
          });
        });

        // Grow wrapper so page is scrollable to see all pieces
        const maxOff = pieces[pieces.length - 1].offsetY;
        wrapper.style.paddingBottom = (maxOff + 40) + 'px';

        invalidateLayoutCache();
        return true;
      }

      // ---- Cursor proximity & visual state (desktop) ----

      let nearEdge = false;

      function getCursorProximity(mouseX: number, mouseY: number): { proximity: number; canCut: boolean } {
        if (!canCutDuringPrint()) return { proximity: 0, canCut: false };
        if (handMode || washiMode || cutMode) return { proximity: 0, canCut: false };

        let distX = 0;
        let minDistY = Infinity;
        let insideTearable = false;

        if (!tearSystemReady || pieces.length === 0) {
          const rr = receipt!.getBoundingClientRect();

          // Horizontal distance to receipt
          if (mouseX < rr.left) distX = rr.left - mouseX;
          else if (mouseX > rr.right) distX = mouseX - rr.right;
          if (distX > PROXIMITY_RANGE) return { proximity: 0, canCut: false };

          const innerTop = rr.top + CUT_EDGE_SAFETY;
          const innerBottom = rr.bottom - CUT_EDGE_SAFETY;
          if (mouseY >= innerTop && mouseY <= innerBottom) {
            insideTearable = true;
            minDistY = 0;
          } else {
            if (mouseY < innerTop) minDistY = innerTop - mouseY;
            else minDistY = mouseY - innerBottom;
          }
        } else {
          // Use each piece's actual bounding rect (accounts for rotation/transforms)
          // When pieces overlap, prefer the topmost (highest z-index)
          distX = Infinity;
          let bestInsideZ = -1;
          for (const p of pieces) {
            const pieceRect = p.el.getBoundingClientRect();

            let pdx = 0;
            if (mouseX < pieceRect.left) pdx = pieceRect.left - mouseX;
            else if (mouseX > pieceRect.right) pdx = mouseX - pieceRect.right;
            if (pdx > PROXIMITY_RANGE) continue;

            const innerTop = pieceRect.top + CUT_EDGE_SAFETY;
            const innerBot = pieceRect.bottom - CUT_EDGE_SAFETY;
            if (mouseY >= innerTop && mouseY <= innerBot) {
              const z = parseInt(p.el.style.zIndex) || 0;
              if (z > bestInsideZ) {
                bestInsideZ = z;
                insideTearable = true;
                minDistY = 0;
                distX = pdx;
              }
              continue;
            }
            if (insideTearable) continue; // already found an exact hit, skip proximity-only pieces
            let d = Infinity;
            if (mouseY < innerTop) d = innerTop - mouseY;
            else if (mouseY > innerBot) d = mouseY - innerBot;
            if (d < minDistY) {
              minDistY = d;
              distX = pdx;
            }
          }
          if (distX === Infinity) distX = PROXIMITY_RANGE + 1;
        }

        const totalDist = Math.sqrt(distX * distX + minDistY * minDistY);
        const canCut = (insideTearable || minDistY <= CUT_EDGE_PADDING) && distX <= CUT_EDGE_PADDING;
        const proximity = insideTearable ? 1 : Math.max(0, 1 - totalDist / PROXIMITY_RANGE);

        return { proximity, canCut };
      }

      function updateCursorVisual(proximity: number, canCut: boolean, isTearing: boolean) {
        if (!cursorDot) return;

        let size: number;
        if (isTearing) {
          size = DOT_SIZE_MIN;
        } else if (canCut) {
          size = DOT_SIZE_MAX;
        } else {
          size = DOT_SIZE_MIN + (DOT_SIZE_MAX - DOT_SIZE_MIN) * proximity;
        }

        cursorDot.style.setProperty('--dot-size', size + 'px');
      }

      function checkEdgeProximity(mouseX: number, mouseY: number) {
        if (washiMode) {
          nearEdge = false;
          updateCursorVisual(0, false, false);
          return;
        }
        if (!canCutDuringPrint()) {
          nearEdge = false;
          updateCursorVisual(0, false, false);
          return;
        }
        const { proximity, canCut } = getCursorProximity(mouseX, mouseY);
        nearEdge = canCut;
        updateCursorVisual(proximity, canCut, false);
      }

      function finishWashiStroke(stroke: TapeStroke) {
        if (!washiMode) return;
        if (Math.hypot(stroke.endX - stroke.startX, stroke.endY - stroke.startY) < MIN_WASHI_STROKE) return;
        let seamIdx = findSeamIndexForStroke(stroke);
        let merged = seamIdx >= 0 ? mergePiecesAt(seamIdx, stroke) : false;
        if (!merged) {
          seamIdx = findNearestSeamByMidpoint(stroke);
          if (seamIdx >= 0) {
            merged = mergePiecesAt(seamIdx, stroke);
          }
        }
        if (!merged) {
          addFreeWashiStrip(stroke);
        }
      }

      function startWashiStroke(clientX: number, clientY: number) {
        dismissHint();
        washiDrawing = true;
        washiStartX = clientX;
        washiStartY = clientY;
        washiCurrentX = clientX;
        washiCurrentY = clientY;
        washiStartScrollX = window.scrollX;
        washiStartScrollY = window.scrollY;
        washiPreviewClip = createWashiClipPath();
        washiPreview.style.setProperty('--washi-alpha', (0.82 + Math.random() * 0.10).toFixed(2));
        document.documentElement.style.touchAction = 'none';
        updateWashiPreview();
      }

      function updateWashiStroke(clientX: number, clientY: number) {
        if (!washiDrawing) return;
        washiCurrentX = clientX;
        washiCurrentY = clientY;
        updateWashiPreview();
      }

      function endWashiStroke() {
        if (!washiDrawing) return;
        if (!washiMode && !handMode && !cutMode) document.documentElement.style.touchAction = '';
        const scrollDX = window.scrollX - washiStartScrollX;
        const scrollDY = window.scrollY - washiStartScrollY;
        const stroke: TapeStroke = {
          startX: washiStartX - scrollDX,
          startY: washiStartY - scrollDY,
          endX: washiCurrentX,
          endY: washiCurrentY,
        };
        washiDrawing = false;
        hideWashiPreview();
        finishWashiStroke(stroke);
      }

      if (usePointerWashi) {
        document.addEventListener('pointerdown', (e: PointerEvent) => {
          if (!washiMode) return;
          if (e.isPrimary === false) return;
          if (e.pointerType === 'mouse' && e.button !== 0) return;
          if ((e.target as HTMLElement).closest('button')) return;
          if ((e.target as HTMLElement).closest('a')) return;
          if (!washiDrawing && activeWashiPointerId !== null) activeWashiPointerId = null;
          if (washiDrawing) return;
          activeWashiPointerId = e.pointerId;
          startWashiStroke(e.clientX, e.clientY);
          e.preventDefault();
        });

        document.addEventListener('pointermove', (e: PointerEvent) => {
          if (!washiMode || activeWashiPointerId !== e.pointerId) return;
          updateWashiStroke(e.clientX, e.clientY);
          e.preventDefault();
        });

        document.addEventListener('pointerup', (e: PointerEvent) => {
          if (activeWashiPointerId !== e.pointerId) return;
          updateWashiStroke(e.clientX, e.clientY);
          activeWashiPointerId = null;
          endWashiStroke();
          e.preventDefault();
        });
        document.addEventListener('pointercancel', (e: PointerEvent) => {
          if (activeWashiPointerId !== e.pointerId) return;
          activeWashiPointerId = null;
          endWashiStroke();
        });
      }

      // ---- Freehand cut gesture (shared state for desktop + mobile) ----

      const cutSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      Object.assign(cutSvg.style, {
        position: 'fixed',
        left: '0',
        top: '0',
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
        zIndex: '10100',
        display: 'none',
      });
      document.body.appendChild(cutSvg);

      const cutTrail = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
      cutTrail.setAttribute('fill', 'none');
      cutTrail.setAttribute('stroke', 'white');
      cutTrail.setAttribute('stroke-width', '1.5');
      cutTrail.setAttribute('stroke-linecap', 'round');
      cutTrail.setAttribute('opacity', '0.2');
      cutSvg.appendChild(cutTrail);

      const cutShimmer = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
      cutShimmer.setAttribute('fill', 'none');
      cutShimmer.setAttribute('stroke', 'white');
      cutShimmer.setAttribute('stroke-width', '2.5');
      cutShimmer.setAttribute('stroke-linecap', 'round');
      cutShimmer.setAttribute('stroke-dasharray', '8 48');
      cutShimmer.setAttribute('opacity', '0.9');
      cutShimmer.style.animation = 'cut-shimmer 0.8s linear infinite';
      cutSvg.appendChild(cutShimmer);

      if (!desktopFinePointer) {
        cutTrail.setAttribute('stroke-width', '3');
        cutTrail.setAttribute('opacity', '0.35');
        cutShimmer.setAttribute('stroke-width', '4');
        cutShimmer.setAttribute('stroke-dasharray', '12 28');
        cutShimmer.style.animation = 'cut-shimmer-mobile 0.6s linear infinite';
      }

      let cutDrawing = false;
      let cutPoints: { x: number; y: number }[] = [];
      const CUT_MIN_DIST = 4;

      cleanupCutStroke = () => {
        if (cutDrawing) {
          cutDrawing = false;
          cutPoints = [];
          cutSvg.style.display = 'none';
          cutTrail.setAttribute('points', '');
          cutShimmer.setAttribute('points', '');
        }
        if (!washiMode && !handMode) {
          document.documentElement.style.touchAction = '';
        }
      };

      function updateCutTrail() {
        const pts = cutPoints.map(p => `${p.x},${p.y}`).join(' ');
        cutTrail.setAttribute('points', pts);
        cutShimmer.setAttribute('points', pts);
      }

      // ---- Desktop click-to-tear ----

      if (desktopFinePointer) {
        let desktopTearing = false;
        let desktopTearStartX = 0;
        let desktopTearStartY = 0;
        let desktopTearDecided = false;

        document.addEventListener('mousemove', (e: MouseEvent) => {
          if (handMode || cutMode) return;
          if (washiDrawing && (!usePointerWashi || activeWashiPointerId === null)) {
            washiCurrentX = e.clientX;
            washiCurrentY = e.clientY;
            updateWashiPreview();
            return;
          }
          if (!desktopTearing) {
            checkEdgeProximity(e.clientX, e.clientY);
          }
        });

        document.addEventListener('mousedown', (e: MouseEvent) => {
          if (handMode) return;
          if ((e.target as HTMLElement).closest('button')) return;
          if ((e.target as HTMLElement).closest('a')) return;

          if (washiMode) {
            e.preventDefault();
            if (usePointerWashi && activeWashiPointerId !== null && washiDrawing) return;
            if (washiDrawing) return;
            startWashiStroke(e.clientX, e.clientY);
            return;
          }

          if (cutMode) return;

          if (!canCutDuringPrint()) return;
          sounds.prepareTearGesture();

          if (!nearEdge) {
            if (!tearSystemReady || pieces.length === 0) {
              const rr = receipt!.getBoundingClientRect();
              if (e.clientX < rr.left - CUT_EDGE_PADDING || e.clientX > rr.right + CUT_EDGE_PADDING) return;
              if (e.clientY < rr.top + CUT_EDGE_SAFETY || e.clientY > rr.bottom - CUT_EDGE_SAFETY) return;
            } else {
              return;
            }
          }

          desktopTearing = true;
          desktopTearStartX = e.clientX;
          desktopTearStartY = e.clientY;
          desktopTearDecided = false;

          updateCursorVisual(1, true, true);
        });

        document.addEventListener('mousemove', (e: MouseEvent) => {
          if (!desktopTearing) return;

          updateCursorVisual(1, true, true);

          const dx = Math.abs(e.clientX - desktopTearStartX);
          const dy = Math.abs(e.clientY - desktopTearStartY);

          if (!desktopTearDecided && (dx > 8 || dy > 8)) {
            desktopTearDecided = true;
            const isHorizontal = dx > dy * 1.2;
            if (!isHorizontal) {
              endDesktopTear();
              return;
            }
            pageCutLine.style.top = `${desktopTearStartY}px`;
            pageCutLine.style.display = 'block';
            pageCutLine.style.width = '0';
          }

          if (!desktopTearDecided) return;

          const progress = Math.min(1, dx / (30));
          pageCutLine.style.width = `${progress * 100}%`;

          if (progress >= 1) {
            executeTear(desktopTearStartX, desktopTearStartY);
            endDesktopTear();
          }
        });

        document.addEventListener('mouseup', () => {
          if (desktopTearing) endDesktopTear();
          if (usePointerWashi && activeWashiPointerId !== null && washiDrawing) return;
          if (!washiDrawing) return;
          endWashiStroke();
        });

        function endDesktopTear() {
          desktopTearing = false;
          desktopTearDecided = false;
          pageCutLine.style.width = '0';
          pageCutLine.style.display = 'none';
          updateCursorVisual(0, false, false);
          setTimeout(() => {
            if (!desktopTearing && !washiMode) checkEdgeProximity(dotTargetX, dotTargetY);
          }, 100);
        }

        // ---- Freehand cut gesture (desktop mouse handlers) ----

        document.addEventListener('mousedown', (e: MouseEvent) => {
          if (!cutMode || handMode || washiMode) return;
          if ((e.target as HTMLElement).closest('button')) return;
          if ((e.target as HTMLElement).closest('a')) return;
          if (!canCutDuringPrint()) return;

          cutDrawing = true;
          cutPoints = [{ x: e.clientX, y: e.clientY }];
          cutSvg.style.display = '';
          updateCutTrail();
          sounds.prepareTearGesture();
        });

        document.addEventListener('mousemove', (e: MouseEvent) => {
          if (!cutDrawing) return;
          const last = cutPoints[cutPoints.length - 1];
          const dx = e.clientX - last.x;
          const dy = e.clientY - last.y;
          if (dx * dx + dy * dy < CUT_MIN_DIST * CUT_MIN_DIST) return;
          cutPoints.push({ x: e.clientX, y: e.clientY });
          updateCutTrail();
        });

        document.addEventListener('mouseup', () => {
          if (!cutDrawing) return;
          cutDrawing = false;

          if (cutPoints.length < 3) {
            cutSvg.style.display = 'none';
            cutTrail.setAttribute('points', '');
            cutShimmer.setAttribute('points', '');
            cutPoints = [];
            return;
          }

          executeCutAll(cutPoints);
          cutSvg.style.display = 'none';
          cutTrail.setAttribute('points', '');
          cutShimmer.setAttribute('points', '');
          cutPoints = [];
        });
      }

      // ---- Hand mode: piece dragging with physics ----

      let handDragging = false;
      let handDragPiece: TearPiece | null = null;
      let handDragStartX = 0;
      let handDragStartY = 0;
      let handDragOrigOffsetX = 0;
      let handDragOrigOffsetY = 0;
      let handDragStartScrollX = 0;
      let handDragStartScrollY = 0;
      let activeHandPointerId: number | null = null;
      const HAND_EDGE_PADDING = 50;

      const HAND_VELOCITY_SAMPLES = 5;
      let handVelocitySamples: { x: number; y: number; t: number }[] = [];

      const HAND_FRICTION = 0.92;
      const HAND_MIN_VELOCITY = 0.5;
      const HAND_ROTATION_FACTOR = 0.08;
      const HAND_MAX_ROTATION_DELTA = 15;

      let handPhysicsActive = false;
      type PhysicsPiece = { piece: TearPiece; vx: number; vy: number; vRot: number };
      let physicsQueue: PhysicsPiece[] = [];

      // Cached layout measurements to avoid per-frame getBoundingClientRect
      let _layoutDirty = true;
      let _cachedParentRect: DOMRect | null = null;
      let _cachedReceiptRect: DOMRect | null = null;
      function invalidateLayoutCache() { _layoutDirty = true; }
      window.addEventListener('resize', invalidateLayoutCache);
      window.addEventListener('orientationchange', invalidateLayoutCache);
      window.addEventListener('scroll', invalidateLayoutCache, { passive: true });
      function refreshLayoutCache() {
        if (!_layoutDirty && _cachedParentRect) return;
        _cachedParentRect = receipt!.parentElement!.getBoundingClientRect();
        _cachedReceiptRect = receipt!.getBoundingClientRect();
        _layoutDirty = false;
      }
      let handZCounter = 20;

      function findPieceByEl(el: HTMLElement): TearPiece | null {
        const pieceEl = el.closest('.receipt-piece') as HTMLElement | null;
        if (!pieceEl) return null;
        return pieces.find(p => p.el === pieceEl) || null;
      }

      function computeReleaseVelocity(): { vx: number; vy: number } {
        if (handVelocitySamples.length < 2) return { vx: 0, vy: 0 };
        const newest = handVelocitySamples[handVelocitySamples.length - 1];
        const oldest = handVelocitySamples[0];
        const dt = (newest.t - oldest.t) / 1000;
        if (dt < 0.001) return { vx: 0, vy: 0 };
        const frameTime = 1 / 60;
        return {
          vx: ((newest.x - oldest.x) / dt) * frameTime,
          vy: ((newest.y - oldest.y) / dt) * frameTime,
        };
      }

      function snapPieceIntoBounds(piece: TearPiece) {
        refreshLayoutCache();
        const parentRect = _cachedParentRect!;
        const baseCX = parentRect.left + parentRect.width / 2;
        const rr = _cachedReceiptRect!;
        const rh = rr.height;
        const vw = window.innerWidth;
        const vh = window.innerHeight;

        let corrected = false;
        const minOX = HAND_EDGE_PADDING - baseCX;
        const maxOX = vw - HAND_EDGE_PADDING - baseCX;
        if (piece.offsetX < minOX) { piece.offsetX = minOX; corrected = true; }
        else if (piece.offsetX > maxOX) { piece.offsetX = maxOX; corrected = true; }

        const pieceBot0 = rr.top + (polyBottom(piece) / 100) * rh;
        const pieceTop0 = rr.top + (polyTop(piece) / 100) * rh;
        const minOY = HAND_EDGE_PADDING - pieceBot0;
        const maxOY = vh - HAND_EDGE_PADDING - pieceTop0;
        if (piece.offsetY < minOY) { piece.offsetY = minOY; corrected = true; }
        else if (piece.offsetY > maxOY) { piece.offsetY = maxOY; corrected = true; }

        if (corrected) {
          piece.el.style.transition = 'transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
          piece.el.style.transform = transformFor(piece);
        }
      }

      function handPhysicsTick() {
        refreshLayoutCache();
        const parentRect = _cachedParentRect!;
        const baseCX = parentRect.left + parentRect.width / 2;
        const rr = _cachedReceiptRect!;
        const rh = rr.height;
        const vw = window.innerWidth;
        const vh = window.innerHeight;

        for (let i = physicsQueue.length - 1; i >= 0; i--) {
          const pp = physicsQueue[i];
          pp.piece.offsetX += pp.vx;
          pp.piece.offsetY += pp.vy;
          pp.piece.rotation += pp.vRot;

          const minOX = HAND_EDGE_PADDING - baseCX;
          const maxOX = vw - HAND_EDGE_PADDING - baseCX;
          if (pp.piece.offsetX < minOX) { pp.piece.offsetX = minOX; pp.vx = 0; }
          else if (pp.piece.offsetX > maxOX) { pp.piece.offsetX = maxOX; pp.vx = 0; }

          const pieceTop0 = rr.top + (polyTop(pp.piece) / 100) * rh;
          const pieceBot0 = rr.top + (polyBottom(pp.piece) / 100) * rh;
          const minOY = HAND_EDGE_PADDING - pieceBot0;
          const maxOY = vh - HAND_EDGE_PADDING - pieceTop0;
          if (pp.piece.offsetY < minOY) { pp.piece.offsetY = minOY; pp.vy = 0; }
          else if (pp.piece.offsetY > maxOY) { pp.piece.offsetY = maxOY; pp.vy = 0; }

          pp.vx *= HAND_FRICTION;
          pp.vy *= HAND_FRICTION;
          pp.vRot *= HAND_FRICTION;
          pp.piece.el.style.transition = 'none';
          pp.piece.el.style.transform = transformFor(pp.piece);
          if (Math.abs(pp.vx) < HAND_MIN_VELOCITY && Math.abs(pp.vy) < HAND_MIN_VELOCITY && Math.abs(pp.vRot) < 0.01) {
            physicsQueue.splice(i, 1);
          }
        }
        if (physicsQueue.length > 0) {
          requestAnimationFrame(handPhysicsTick);
        } else {
          handPhysicsActive = false;
        }
      }

      document.addEventListener('pointerdown', (e: PointerEvent) => {
        if (!handMode || !e.isPrimary) return;
        if ((e.target as HTMLElement).closest('button, a')) return;
        if (handDragging) return;
        const piece = findPieceByEl(e.target as HTMLElement);
        if (!piece) return;

        dismissHint();
        activeHandPointerId = e.pointerId;
        handDragging = true;
        handDragPiece = piece;
        handDragStartX = e.clientX;
        handDragStartY = e.clientY;
        handDragOrigOffsetX = piece.offsetX;
        handDragOrigOffsetY = piece.offsetY;
        handDragStartScrollX = window.scrollX;
        handDragStartScrollY = window.scrollY;

        handZCounter++;
        piece.el.style.zIndex = String(handZCounter);
        piece.el.style.transition = 'none';

        // Remove from physics queue if mid-fling
        physicsQueue = physicsQueue.filter(pq => pq.piece !== piece);

        handVelocitySamples = [{ x: e.clientX, y: e.clientY, t: performance.now() }];
        document.body.classList.add('hand-dragging');
        e.preventDefault();
      });

      document.addEventListener('pointermove', (e: PointerEvent) => {
        if (!handMode || !handDragging || activeHandPointerId !== e.pointerId) return;
        if (!handDragPiece) return;

        const scrollDX = window.scrollX - handDragStartScrollX;
        const scrollDY = window.scrollY - handDragStartScrollY;
        handDragPiece.offsetX = handDragOrigOffsetX + (e.clientX - handDragStartX) + scrollDX;
        handDragPiece.offsetY = handDragOrigOffsetY + (e.clientY - handDragStartY) + scrollDY;
        handDragPiece.el.style.transform = transformFor(handDragPiece);

        handVelocitySamples.push({ x: e.clientX, y: e.clientY, t: performance.now() });
        if (handVelocitySamples.length > HAND_VELOCITY_SAMPLES) handVelocitySamples.shift();
        e.preventDefault();
      });

      document.addEventListener('pointerup', (e: PointerEvent) => {
        if (activeHandPointerId !== e.pointerId) return;
        if (!handDragging || !handDragPiece) {
          activeHandPointerId = null;
          return;
        }

        const releasedPiece = handDragPiece;
        const { vx, vy } = computeReleaseVelocity();
        const rotDelta = Math.max(-HAND_MAX_ROTATION_DELTA, Math.min(HAND_MAX_ROTATION_DELTA, vx * HAND_ROTATION_FACTOR));

        if (Math.abs(vx) > HAND_MIN_VELOCITY || Math.abs(vy) > HAND_MIN_VELOCITY) {
          physicsQueue.push({ piece: releasedPiece, vx, vy, vRot: rotDelta * 0.1 });
          if (!handPhysicsActive) {
            handPhysicsActive = true;
            requestAnimationFrame(handPhysicsTick);
          }
        } else {
          // No fling — snap back if piece was dropped outside viewport
          snapPieceIntoBounds(releasedPiece);
        }

        document.body.classList.remove('hand-dragging');
        handDragging = false;
        handDragPiece = null;
        activeHandPointerId = null;
      });

      document.addEventListener('pointercancel', (e: PointerEvent) => {
        if (activeHandPointerId !== e.pointerId) return;
        if (handDragPiece) snapPieceIntoBounds(handDragPiece);
        document.body.classList.remove('hand-dragging');
        handDragging = false;
        handDragPiece = null;
        activeHandPointerId = null;
      });

      document.addEventListener('keydown', (e: KeyboardEvent) => {
        if (e.repeat) return;
        const key = e.key.toLowerCase();
        const el = document.activeElement as HTMLElement;
        if (el && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.isContentEditable)) return;
        if (key === 'w') {
          washiMode = !washiMode;
          if (!washiMode) cleanupWashiStroke();
          syncWashiToggle();
          flashButton(tapeToggle);
          e.preventDefault();
        } else if (key === 'c' && washiMode) {
          clearAllTape();
          flashButton(clearTapeBtn);
          e.preventDefault();
        } else if (key === 's') {
          toggleSound();
          flashButton(soundToggle);
          e.preventDefault();
        } else if (key === 'h') {
          toggleHandMode();
          flashButton(handToggleBtn);
          e.preventDefault();
        } else if (key === 'x') {
          toggleCutMode();
          flashButton(cutToggleBtn);
          e.preventDefault();
        } else if (key === 'r') {
          resetToDefault();
          flashButton(resetBtn);
          e.preventDefault();
        }
      });

      // ---- Touch gesture detection (swipe anywhere, mobile) ----

      let tearStartX = 0;
      let tearStartY = 0;
      let tearLastX = 0;
      let tearLastY = 0;
      let isTearing = false;
      let tearDecided = false;
      let tearIsHorizontal = false;
      let tearReady = false;

      function startTear(cx: number, cy: number) {
        if (washiMode || handMode) return;
        if (!canCutDuringPrint()) return;
        dismissHint();
        sounds.prepareTearGesture();
        tearStartX = cx;
        tearStartY = cy;
        tearLastX = cx;
        tearLastY = cy;
        isTearing = true;
        tearDecided = false;
        tearIsHorizontal = false;
        tearReady = false;
      }

      function moveTear(cx: number, cy: number) {
        if (!isTearing) return;
        tearLastX = cx;
        tearLastY = cy;
        const dx = Math.abs(cx - tearStartX);
        const dy = Math.abs(cy - tearStartY);

        if (!tearDecided && (dx > 12 || dy > 12)) {
          tearDecided = true;
          tearIsHorizontal = dx > dy * 1.2;
          if (tearIsHorizontal) {
            document.documentElement.style.touchAction = 'none';
            pageCutLine.style.top = `${tearStartY}px`;
            pageCutLine.style.display = 'block';
            pageCutLine.style.width = '0';
            // Mobile should tear reliably even on shorter swipes once direction is clear.
            tearReady = true;
          }
        }

        if (!tearDecided || !tearIsHorizontal) return;

        const progress = Math.min(1, dx / (30));
        pageCutLine.style.width = `${progress * 100}%`;

        if (progress >= 1) {
          tearReady = true;
          pageCutLine.style.width = '100%';
        }
      }

      function endTear() {
        pageCutLine.style.width = '0';
        pageCutLine.style.display = 'none';
        isTearing = false;
        tearDecided = false;
        tearIsHorizontal = false;
        tearReady = false;
        if (!washiMode && !handMode && !cutMode) document.documentElement.style.touchAction = '';
      }

      // Touch (swipe gesture stays the same for mobile)
      document.addEventListener('touchstart', (e: TouchEvent) => {
        if (handMode) return;
        if ((e.target as HTMLElement).closest('button')) return;
        if ((e.target as HTMLElement).closest('a')) return;
        if (washiMode) {
          if (usePointerWashi && activeWashiPointerId !== null && washiDrawing) return;
          if (e.touches.length === 0) return;
          if (washiDrawing) return;
          startWashiStroke(e.touches[0].clientX, e.touches[0].clientY);
          return;
        }
        if (cutMode) {
          if (e.touches.length === 0) return;
          if (!canCutDuringPrint()) return;
          cutDrawing = true;
          cutPoints = [{ x: e.touches[0].clientX, y: e.touches[0].clientY }];
          cutSvg.style.display = '';
          updateCutTrail();
          sounds.prepareTearGesture();
          return;
        }
        startTear(e.touches[0].clientX, e.touches[0].clientY);
      }, { passive: true });
      document.addEventListener('touchmove', (e: TouchEvent) => {
        if (handMode) return;
        if (washiMode && washiDrawing) {
          if (activeWashiPointerId === null && e.touches.length > 0) {
            updateWashiStroke(e.touches[0].clientX, e.touches[0].clientY);
          }
          return;
        }
        if (cutDrawing && e.touches.length > 0) {
          const last = cutPoints[cutPoints.length - 1];
          const dx = e.touches[0].clientX - last.x;
          const dy = e.touches[0].clientY - last.y;
          if (dx * dx + dy * dy >= CUT_MIN_DIST * CUT_MIN_DIST) {
            cutPoints.push({ x: e.touches[0].clientX, y: e.touches[0].clientY });
            updateCutTrail();
          }
          return;
        }
        if (isTearing && e.touches.length > 0) {
          moveTear(e.touches[0].clientX, e.touches[0].clientY);
        }
      }, { passive: true });
      document.addEventListener('touchend', (e: TouchEvent) => {
        if (handMode) return;
        if (washiMode && washiDrawing && (!usePointerWashi || activeWashiPointerId === null)) {
          endWashiStroke();
          return;
        }
        if (cutDrawing) {
          cutDrawing = false;
          if (cutPoints.length >= 3) {
            executeCutAll(cutPoints);
          }
          cutSvg.style.display = 'none';
          cutTrail.setAttribute('points', '');
          cutShimmer.setAttribute('points', '');
          cutPoints = [];
          return;
        }
        if (e.changedTouches.length > 0) {
          tearLastX = e.changedTouches[0].clientX;
          tearLastY = e.changedTouches[0].clientY;
        }
        const finalDx = Math.abs(tearLastX - tearStartX);
        const finalDy = Math.abs(tearLastY - tearStartY);
        const finalHorizontal = finalDx > 12 && finalDx > finalDy * 1.2;
        if (isTearing && tearReady) {
          executeTear(tearStartX, tearStartY);
        } else if (isTearing && finalHorizontal) {
          executeTear(tearStartX, tearStartY);
        }
        if (isTearing) endTear();
      });
    }

    // ========================================
    // 7. KICK OFF THE PRINTING
    // ========================================
    startPrinting();

  });
</script>
